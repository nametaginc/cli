// Copyright 2024 Nametag Inc.
//
// All information contained herein is the property of Nametag Inc.. The
// intellectual and technical concepts contained herein are proprietary, trade
// secrets, and/or confidential to Nametag, Inc. and may be covered by U.S.
// and Foreign Patents, patents in process, and are protected by trade secret or
// copyright law. Reproduction or distribution, in whole or in part, is
// forbidden except by express written permission of Nametag, Inc.

// Automatically generated. Do not edit.

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"

	"github.com/nametaginc/cli/internal/pkg/jsonx"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
	NoneScopes   = "none.Scopes"
)

// Defines values for AccountBulkUpdateStatus.
const (
	AccountBulkUpdateItemStatusBadRequest AccountBulkUpdateStatus = 400
	AccountBulkUpdateItemStatusConflict   AccountBulkUpdateStatus = 409
	AccountBulkUpdateItemStatusNotFound   AccountBulkUpdateStatus = 404
	AccountBulkUpdateItemStatusOK         AccountBulkUpdateStatus = 204
)

// Defines values for AuditEventKind.
const (
	AuditEventKindAPIKeyCreated                    AuditEventKind = "apikey_created"
	AuditEventKindAPIKeyDeleted                    AuditEventKind = "apikey_deleted"
	AuditEventKindAPIKeyUpdated                    AuditEventKind = "apikey_updated"
	AuditEventKindAccountPhotoUploaded             AuditEventKind = "account_photo_uploaded"
	AuditEventKindAccountUpdated                   AuditEventKind = "account_updated"
	AuditEventKindCLISignin                        AuditEventKind = "cli_signin"
	AuditEventKindConsoleSignin                    AuditEventKind = "console_signin"
	AuditEventKindConsoleSinginConfigureEmail      AuditEventKind = "console_singin_configure_email"
	AuditEventKindConsoleSinginConfigureSAML       AuditEventKind = "console_singin_configure_saml"
	AuditEventKindDirectoryAuthorized              AuditEventKind = "directory_authorized"
	AuditEventKindDirectoryCreated                 AuditEventKind = "directory_created"
	AuditEventKindDirectoryDeleted                 AuditEventKind = "directory_deleted"
	AuditEventKindDirectoryLogoDeleted             AuditEventKind = "directory_logo_deleted"
	AuditEventKindDirectoryLogoUploaded            AuditEventKind = "directory_logo_uploaded"
	AuditEventKindDirectorySetCredentials          AuditEventKind = "directory_set_credentials"
	AuditEventKindDirectoryUpdated                 AuditEventKind = "directory_updated"
	AuditEventKindEntraEamAuthorize                AuditEventKind = "entra_eam_authorize"
	AuditEventKindEntraEamFinish                   AuditEventKind = "entra_eam_finish"
	AuditEventKindEnvCreated                       AuditEventKind = "env_created"
	AuditEventKindEnvDeleted                       AuditEventKind = "env_deleted"
	AuditEventKindEnvLogoDeleted                   AuditEventKind = "env_logo_deleted"
	AuditEventKindEnvLogoUploaded                  AuditEventKind = "env_logo_uploaded"
	AuditEventKindEnvUpdated                       AuditEventKind = "env_updated"
	AuditEventKindEnvWebhookSecretUpdated          AuditEventKind = "env_webhook_secret_updated"
	AuditEventKindExtensionInvoked                 AuditEventKind = "extension_invoked"
	AuditEventKindOAuth2Authorize                  AuditEventKind = "oauth2_authorize"
	AuditEventKindOAuth2PushedAuthorizationRequest AuditEventKind = "oauth2_pushed_authorization_request"
	AuditEventKindOAuth2RequestCanceled            AuditEventKind = "oauth2_request_canceled"
	AuditEventKindOAuth2Token                      AuditEventKind = "oauth2_token"
	AuditEventKindOAuth2V2Authorize                AuditEventKind = "oauth2_v2_authorize"
	AuditEventKindOktaEamAuthorize                 AuditEventKind = "okta_eam_authorize"
	AuditEventKindOktaEamFinish                    AuditEventKind = "okta_eam_finish"
	AuditEventKindOrgMemberInvited                 AuditEventKind = "org_member_invited"
	AuditEventKindOrgMemberRemoved                 AuditEventKind = "org_member_removed"
	AuditEventKindOrgMemberUpdated                 AuditEventKind = "org_member_updated"
	AuditEventKindOrgUpdated                       AuditEventKind = "org_updated"
	AuditEventKindPeopleCompare                    AuditEventKind = "people_compare"
	AuditEventKindRequestCanceled                  AuditEventKind = "request_canceled"
	AuditEventKindRequestCreated                   AuditEventKind = "request_created"
	AuditEventKindRequestUpdated                   AuditEventKind = "request_updated"
	AuditEventKindSelfieCompare                    AuditEventKind = "selfie_compare"
	AuditEventKindSharingRevoked                   AuditEventKind = "sharing_revoked"
	AuditEventKindTemplateCreated                  AuditEventKind = "template_created"
	AuditEventKindTemplateDeleted                  AuditEventKind = "template_deleted"
	AuditEventKindTemplateUpdated                  AuditEventKind = "template_updated"
)

// Defines values for AuthorizeRequestCodeChallengeMethod.
const (
	AuthorizeRequestCodeChallengeMethodPlain AuthorizeRequestCodeChallengeMethod = "plain"
	AuthorizeRequestCodeChallengeMethodS256  AuthorizeRequestCodeChallengeMethod = "S256"
)

// Defines values for AuthorizeRequestResponseMode.
const (
	AuthorizeRequestResponseModeFragment AuthorizeRequestResponseMode = "fragment"
)

// Defines values for AuthorizeRequestResponseType.
const (
	AuthorizeRequestResponseTypeCode AuthorizeRequestResponseType = "code"
)

// Defines values for AuthorizeReturn.
const (
	AuthorizeReturnChrome  AuthorizeReturn = "chrome"
	AuthorizeReturnFirefox AuthorizeReturn = "firefox"
	AuthorizeReturnHTTPS   AuthorizeReturn = "https"
	AuthorizeReturnNone    AuthorizeReturn = ""
)

// Defines values for AuthorizeStatus.
const (
	AuthorizeStatusComplete AuthorizeStatus = 200
	AuthorizeStatusExpired  AuthorizeStatus = 510
	AuthorizeStatusPending  AuthorizeStatus = 100
	AuthorizeStatusRejected AuthorizeStatus = 403
)

// Defines values for BadRequestResponseStatus.
const (
	BadRequestResponseStatusN400 BadRequestResponseStatus = 400
)

// Defines values for Claim.
const (
	ClaimAccount       Claim = "account"
	ClaimAddress       Claim = "address"
	ClaimBirthDate     Claim = "birth_date"
	ClaimEmail         Claim = "email"
	ClaimFamilyName    Claim = "family_name"
	ClaimGivenName     Claim = "given_name"
	ClaimGovtid        Claim = "govtid"
	ClaimGovtidExpired Claim = "govtid_expired"
	ClaimGpsLocation   Claim = "gps_location"
	ClaimIpLocation    Claim = "ip_location"
	ClaimName          Claim = "name"
	ClaimPhoneNumber   Claim = "phone_number"
	ClaimPicture       Claim = "picture"
	ClaimPreferredName Claim = "preferred_name"
)

// Defines values for DirectoryKind.
const (
	DirectoryKindAzureAD        DirectoryKind = "azure-ad"
	DirectoryKindBeyondIdentity DirectoryKind = "beyond-identity"
	DirectoryKindCustom         DirectoryKind = "custom"
	DirectoryKindDuo            DirectoryKind = "duo"
	DirectoryKindOkta           DirectoryKind = "okta"
	DirectoryKindOnelogin       DirectoryKind = "onelogin"
)

// Defines values for EnvStatusFilterParams.
const (
	Active               EnvStatusFilterParams = "active"
	Expired              EnvStatusFilterParams = "expired"
	HideExpired          EnvStatusFilterParams = "hideExpired"
	RejectedAll          EnvStatusFilterParams = "rejectedAll"
	RejectedFraud        EnvStatusFilterParams = "rejectedFraud"
	ScheduledForDeletion EnvStatusFilterParams = "scheduledForDeletion"
)

// Defines values for EnvUpdatedAtFilterParams.
const (
	All       EnvUpdatedAtFilterParams = "all"
	Lastmonth EnvUpdatedAtFilterParams = "lastmonth"
	Month     EnvUpdatedAtFilterParams = "month"
	Today     EnvUpdatedAtFilterParams = "today"
	Week      EnvUpdatedAtFilterParams = "week"
	Year      EnvUpdatedAtFilterParams = "year"
)

// Defines values for GovtidType.
const (
	DriverLicense GovtidType = "driver_license"
	Passport      GovtidType = "passport"
)

// Defines values for LogoKind.
const (
	Install LogoKind = "install"
	Mobile  LogoKind = "mobile"
	Qr      LogoKind = "qr"
)

// Defines values for NumericRequestStatus.
const (
	NumericRequestStatusCancelled        NumericRequestStatus = 404
	NumericRequestStatusCompleted        NumericRequestStatus = 200
	NumericRequestStatusExpired          NumericRequestStatus = 410
	NumericRequestStatusExpiredScopes    NumericRequestStatus = 411
	NumericRequestStatusInProgress       NumericRequestStatus = 101
	NumericRequestStatusPending          NumericRequestStatus = 100
	NumericRequestStatusRejectedFraud    NumericRequestStatus = 552
	NumericRequestStatusRejectedInReview NumericRequestStatus = 550
	NumericRequestStatusRejectedUnusable NumericRequestStatus = 551
	NumericRequestStatusRevoked          NumericRequestStatus = 403
)

// Defines values for PushedAuthorizationRequestCodeChallengeMethod.
const (
	PushedAuthorizationRequestCodeChallengeMethodPlain PushedAuthorizationRequestCodeChallengeMethod = "plain"
	PushedAuthorizationRequestCodeChallengeMethodS256  PushedAuthorizationRequestCodeChallengeMethod = "S256"
)

// Defines values for PushedAuthorizationRequestResponseMode.
const (
	PushedAuthorizationRequestResponseModeFragment PushedAuthorizationRequestResponseMode = "fragment"
)

// Defines values for PushedAuthorizationRequestResponseType.
const (
	PushedAuthorizationRequestResponseTypeCode PushedAuthorizationRequestResponseType = "code"
)

// Defines values for RecoveryMicrositeFlow.
const (
	MicrositeFlowBadge           RecoveryMicrositeFlow = "badge"
	RecoveryMicrositeFlowEnroll  RecoveryMicrositeFlow = "enroll"
	RecoveryMicrositeFlowRecover RecoveryMicrositeFlow = "recover"
)

// Defines values for RecoveryMicrositeOperation.
const (
	Mfa                 RecoveryMicrositeOperation = "mfa"
	Password            RecoveryMicrositeOperation = "password"
	TemporaryAccessPass RecoveryMicrositeOperation = "temporary-access-pass"
	Unlock              RecoveryMicrositeOperation = "unlock"
)

// Defines values for RecoveryPolicy.
const (
	RecoveryPolicyDisabled         RecoveryPolicy = "disabled"
	RecoveryPolicyNameAndBirthDate RecoveryPolicy = "name_and_birth_date"
	RecoveryPolicyNameMatch        RecoveryPolicy = "name_match"
	RecoveryPolicyPhoto            RecoveryPolicy = "photo"
	RecoveryPolicyWeakNameMatch    RecoveryPolicy = "weak_name_match"
)

// Defines values for RequestProgress.
const (
	RequestProgressAppOpened    RequestProgress = "app_opened"
	RequestProgressConsentGiven RequestProgress = "consent_given"
	RequestProgressFaceScanned  RequestProgress = "face_scanned"
	RequestProgressIDScanned    RequestProgress = "id_scanned"
	RequestProgressInit         RequestProgress = "created"
	RequestProgressLinkOpened   RequestProgress = "link_opened"
)

// Defines values for RequestStatus.
const (
	RequestStatusCancelled        RequestStatus = "cancelled"
	RequestStatusExpired          RequestStatus = "expired"
	RequestStatusExpiredScopes    RequestStatus = "expired_scopes"
	RequestStatusInProgress       RequestStatus = "in_progress"
	RequestStatusPending          RequestStatus = "pending"
	RequestStatusPersonDeleted    RequestStatus = "person_deleted"
	RequestStatusRejectedFraud    RequestStatus = "rejected_fraud"
	RequestStatusRejectedInReview RequestStatus = "rejected_appealed"
	RequestStatusRejectedUnusable RequestStatus = "rejected_unusable"
	RequestStatusRevoked          RequestStatus = "revoked"
	RequestStatusShared           RequestStatus = "shared"
)

// Defines values for RequestVerificationSource.
const (
	RequestVerificationSourceExpressReverification RequestVerificationSource = "express_reverification"
	RequestVerificationSourceFullIDV               RequestVerificationSource = "full_idv"
)

// Defines values for Role.
const (
	RoleAdmin       Role = "admin"
	RoleLimited     Role = "limited"
	RoleLimitedPlus Role = "limited_plus"
	RoleOwner       Role = "owner"
	RoleUser        Role = "user"
)

// Defines values for Scope.
const (
	NtAddress         Scope = "nt:address"
	NtAgeOver18       Scope = "nt:age_over_18"
	NtAgeOver21       Scope = "nt:age_over_21"
	NtBirthDate       Scope = "nt:birth_date"
	NtEmail           Scope = "nt:email"
	NtEmailUnverified Scope = "nt:email:unverified"
	NtFirstName       Scope = "nt:first_name"
	NtGovtidDetails   Scope = "nt:govtid_details"
	NtLastName        Scope = "nt:last_name"
	NtLegalFirstName  Scope = "nt:legal_first_name"
	NtLegalLastName   Scope = "nt:legal_last_name"
	NtLegalName       Scope = "nt:legal_name"
	NtLocationGps     Scope = "nt:location:gps"
	NtLocationIp      Scope = "nt:location:ip"
	NtName            Scope = "nt:name"
	NtPhone           Scope = "nt:phone"
	NtProfilePicture  Scope = "nt:profile_picture"
	Openid            Scope = "openid"
)

// Defines values for TokenRequestGrantType.
const (
	AuthorizationCode TokenRequestGrantType = "authorization_code"
)

// Defines values for TokenResponseTokenType.
const (
	TokenTypeBearer TokenResponseTokenType = "Bearer"
)

// Defines values for WebhookEventType.
const (
	WebhookEventTypeAudit                WebhookEventType = "audit"
	WebhookEventTypeDirectoryProviderErr WebhookEventType = "directory_provider_err"
	WebhookEventTypePicture              WebhookEventType = "picture"
	WebhookEventTypeRecover              WebhookEventType = "recover"
	WebhookEventTypeReject               WebhookEventType = "reject"
	WebhookEventTypeRequest              WebhookEventType = "request"
	WebhookEventTypeShare                WebhookEventType = "share"
)

// Defines values for ListEnvRequestsParamsSort.
const (
	LastCreated      ListEnvRequestsParamsSort = "last_created"
	LastUpdated      ListEnvRequestsParamsSort = "last_updated"
	MinusLastCreated ListEnvRequestsParamsSort = "-last_created"
	MinusLastUpdated ListEnvRequestsParamsSort = "-last_updated"
)

// Defines values for Oauth2AuthorizeParamsResponseType.
const (
	Oauth2AuthorizeParamsResponseTypeCode Oauth2AuthorizeParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeParamsResponseMode.
const (
	Oauth2AuthorizeParamsResponseModeFragment Oauth2AuthorizeParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeParamsCodeChallengeMethod.
const (
	Oauth2AuthorizeParamsCodeChallengeMethodPlain Oauth2AuthorizeParamsCodeChallengeMethod = "plain"
	Oauth2AuthorizeParamsCodeChallengeMethodS256  Oauth2AuthorizeParamsCodeChallengeMethod = "S256"
)

// Defines values for Oauth2AuthorizeIframeParamsResponseType.
const (
	Oauth2AuthorizeIframeParamsResponseTypeCode Oauth2AuthorizeIframeParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeIframeParamsResponseMode.
const (
	Oauth2AuthorizeIframeParamsResponseModeFragment Oauth2AuthorizeIframeParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeIframeParamsCodeChallengeMethod.
const (
	Oauth2AuthorizeIframeParamsCodeChallengeMethodPlain Oauth2AuthorizeIframeParamsCodeChallengeMethod = "plain"
	Oauth2AuthorizeIframeParamsCodeChallengeMethodS256  Oauth2AuthorizeIframeParamsCodeChallengeMethod = "S256"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsResponseType.
const (
	Code Oauth2AuthorizeWithExperienceParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsResponseMode.
const (
	Fragment Oauth2AuthorizeWithExperienceParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod.
const (
	Plain Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod = "plain"
	S256  Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod = "S256"
)

// AccountBulkUpdateStatus A status code that describes whether the operation was successful
type AccountBulkUpdateStatus int

// APIKey defines model for APIKey.
type APIKey struct {
	// ID The unique identifier for the API key
	ID string `json:"id"`

	// Name A descriptive name for the API key
	Name string `json:"name"`

	// CreatedAt When the API key was created
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The OrgMember ID that created this API key.
	CreatedBy *string `json:"created_by,omitempty"`

	// Enabled Whether the API key is enabled.
	Enabled bool `json:"enabled"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs"`
	Role   Role     `json:"role"`

	// ExpiresAt The expiration date and time for the API key. If not provided, the key will not expire. Example: "2023-12-31T23:59:59Z"
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// LastUsedAt The last time the API key was used. This is updated each time the key is used to make a request.
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
}

// APIKeyCreatedAuditEvent defines model for APIKeyCreatedAuditEvent.
type APIKeyCreatedAuditEvent struct {
	Request  CreateAPIKeyRequest  `json:"request"`
	Response CreateAPIKeyResponse `json:"response"`
}

// APIKeyDeletedAuditEvent defines model for APIKeyDeletedAuditEvent.
type APIKeyDeletedAuditEvent struct {
	Apikey string `json:"apikey"`
}

// APIKeyUpdateRequest defines model for APIKeyUpdateRequest.
type APIKeyUpdateRequest struct {
	// Name A descriptive name for the API key
	Name *string `json:"name,omitempty"`

	// Enabled `true` if the API key is enabled, or `false` if it cannot be used.
	Enabled *bool `json:"enabled,omitempty"`
	Role    *Role `json:"role,omitempty"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs,omitempty"`

	// ExpiresAt The expiration date and time for the API key. If not provided, the key will not expire. Example: "2023-12-31T23:59:59Z"
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// APIKeyUpdatedAuditEvent defines model for APIKeyUpdatedAuditEvent.
type APIKeyUpdatedAuditEvent struct {
	Apikey  string              `json:"apikey"`
	Request APIKeyUpdateRequest `json:"request"`
}

// Account defines model for Account.
type Account struct {
	// ID The Nametag identifier for the account.
	ID string `json:"id"`

	// DirectoryIdentifiers The identifiers for the account used by the directory (typically an email address, username)
	DirectoryIdentifiers []string `json:"directory_identifiers"`

	// DirectoryImmutableIdentifier The unchanging identifier for the account used by the directory. Most directories have a UUID or other opaque identifier that doesn't change even when `directory_identifiers` changes.
	DirectoryImmutableIdentifier string `json:"directory_immutable_identifier"`

	// Name The person's name, according to the directory
	Name string `json:"name"`

	// Subject The Nametag Subject for this person, if the account has been bound to a `subject`. Null otherwise.
	Subject *string `json:"subject,omitempty"`

	// HaveBirthDate true if the person's expected birth date has been set for the directory.
	HaveBirthDate *bool         `json:"have_birth_date,omitempty"`
	Photo         *AccountPhoto `json:"photo,omitempty"`
}

// AccountBulkUpdateRequest defines model for AccountBulkUpdateRequest.
type AccountBulkUpdateRequest struct {
	// Accounts A list of account update operations
	Accounts []AccountBulkUpdateRequestItem `json:"accounts"`
}

// AccountBulkUpdateRequestItem defines model for AccountBulkUpdateRequestItem.
type AccountBulkUpdateRequestItem struct {
	// Subject The subject for this person. Set this to an empty string to remove the binding for this person.
	Subject *string `json:"subject,omitempty"`

	// BirthDate The subject's date of birth. If this is set prior to the account being bound to a `subject`, then the birth  date on their ID must match this date. You can also specify the hash or HMAC of the person's birth date.  See [Birth date hashes](/docs/birth-date-hash) for details.
	BirthDate *string `json:"birth_date,omitempty"`

	// ID The unique identifier of the account. This can be the Nametag ID
	// for the account, the immutable ID of the account (e.g. the GUID in
	// Azure AD), or one of the identifiers associated with the account,
	// (e.g. the email address, username, or UPN).
	ID string `json:"id"`
}

// AccountBulkUpdateResponse defines model for AccountBulkUpdateResponse.
type AccountBulkUpdateResponse struct {
	Results []AccountBulkUpdateResponseItem `json:"results"`
}

// AccountBulkUpdateResponseItem The status of each operation specified in the request
type AccountBulkUpdateResponseItem struct {
	// ID The account identifier provided in the request
	ID string `json:"id"`

	// Status A status code that describes whether the operation was successful
	Status AccountBulkUpdateStatus `json:"status"`

	// Error A description of the error that occurred.
	Error *string `json:"error,omitempty"`
}

// AccountPhoto defines model for AccountPhoto.
type AccountPhoto struct {
	// SHA256 The SHA256 hash of the uploaded image.
	SHA256 string `json:"sha256"`

	// CreatedAt The time when the image was added.
	CreatedAt time.Time `json:"created_at"`
}

// AccountPhotoUploadedAuditEvent defines model for AccountPhotoUploadedAuditEvent.
type AccountPhotoUploadedAuditEvent struct {
	Account   string `json:"account"`
	Directory string `json:"directory"`
}

// AccountUpdateRequest defines model for AccountUpdateRequest.
type AccountUpdateRequest struct {
	// Subject The subject for this person. Set this to an empty string to remove the binding for this person.
	Subject *string `json:"subject,omitempty"`

	// BirthDate The subject's date of birth. If this is set prior to the account being bound to a `subject`, then the birth  date on their ID must match this date.
	// You can also specify the hash or HMAC of the person's birth date. See [Birth date hashes](/docs/birth-date-hash) for details.
	BirthDate *string `json:"birth_date,omitempty"`
}

// AccountUpdatedAuditEvent defines model for AccountUpdatedAuditEvent.
type AccountUpdatedAuditEvent struct {
	Account   string               `json:"account"`
	Directory string               `json:"directory"`
	Request   AccountUpdateRequest `json:"request"`
}

// AccountValue defines model for AccountValue.
type AccountValue struct {
	// ImmutableExternalId A GUID that uniquely identifies this entry in the directory, even if the external IDs change
	ImmutableExternalId *string `json:"immutable_external_id,omitempty"`

	// Ids The list of ID's associated with the account
	Ids *[]string `json:"ids,omitempty"`

	// BindingStrength The binding strength used to determine account info
	BindingStrength *string `json:"binding_strength,omitempty"`
}

// AccountsList defines model for AccountsList.
type AccountsList struct {
	// Accounts The list of accounts
	Accounts []Account `json:"accounts"`

	// NextOffset A value for the offset query parameter for the next page of results
	NextOffset *int `json:"next_offset,omitempty"`
}

// AuditEvent defines model for AuditEvent.
type AuditEvent struct {
	// ID The unique identifier for the event.
	// The identifier is in [ULID format](https://github.com/ulid/spec) which  means that you can sort the events by time by sorting by ID.
	ID string `json:"id"`

	// Time The time the event occurred
	Time time.Time      `json:"time"`
	Kind AuditEventKind `json:"kind"`

	// Trace A unique identifier for the event
	Trace string `json:"trace"`

	// Truncated True if the details of this record have been removed because the record would exceed the size limit for audit logs.
	Truncated *bool `json:"truncated,omitempty"`

	// RemoteAddr The IP address of the client that made the request
	RemoteAddr *string `json:"remote_addr,omitempty"`

	// UserAgent The remote user agent of the client that made the request
	UserAgent *string `json:"user_agent,omitempty"`

	// OrgID The ID of the organization for the actor performing the action. This will be the same for all your events.
	OrgID string `json:"org"`

	// EnvID The ID of the environment that this action refers to.
	EnvID                            *string                                     `json:"env,omitempty"`
	Principal                        *Principal                                  `json:"principal,omitempty"`
	EnvCreated                       *EnvCreatedAuditEvent                       `json:"env_created,omitempty"`
	EnvUpdated                       *EnvUpdatedAuditEvent                       `json:"env_updated,omitempty"`
	EnvDeleted                       *EnvDeletedAuditEvent                       `json:"env_deleted,omitempty"`
	EnvLogoUploaded                  *EnvLogoUploadedAuditEvent                  `json:"env_logo_uploaded,omitempty"`
	EnvLogoDeleted                   *EnvLogoDeletedAuditEvent                   `json:"env_logo_deleted,omitempty"`
	TemplateCreated                  *TemplateCreatedAuditEvent                  `json:"template_created,omitempty"`
	TemplateUpdated                  *TemplateUpdatedAuditEvent                  `json:"template_updated,omitempty"`
	TemplateDeleted                  *TemplateDeletedAuditEvent                  `json:"template_deleted,omitempty"`
	EnvWebhookSecretUpdated          *EnvWebhookSecretUpdatedAuditEvent          `json:"env_webhook_secret_updated,omitempty"`
	OrgUpdated                       *OrgUpdatedAuditEvent                       `json:"org_updated,omitempty"`
	OrgMemberInvited                 *OrgMemberInvitedAuditEvent                 `json:"org_member_invited,omitempty"`
	OrgMemberRemoved                 *OrgMemberRemovedAuditEvent                 `json:"org_member_removed,omitempty"`
	OrgMemberUpdated                 *OrgMemberUpdatedAuditEvent                 `json:"org_member_updated,omitempty"`
	ApikeyCreated                    *APIKeyCreatedAuditEvent                    `json:"apikey_created,omitempty"`
	ApikeyUpdated                    *APIKeyUpdatedAuditEvent                    `json:"apikey_updated,omitempty"`
	ApikeyDeleted                    *APIKeyDeletedAuditEvent                    `json:"apikey_deleted,omitempty"`
	RequestCreated                   *RequestCreatedAuditEvent                   `json:"request_created,omitempty"`
	RequestUpdated                   *RequestUpdatedAuditEvent                   `json:"request_updated,omitempty"`
	RequestCanceled                  *RequestCanceledAuditEvent                  `json:"request_canceled,omitempty"`
	AccountUpdated                   *AccountUpdatedAuditEvent                   `json:"account_updated,omitempty"`
	AccountPhotoUploaded             *AccountPhotoUploadedAuditEvent             `json:"account_photo_uploaded,omitempty"`
	DirectoryCreated                 *DirectoryCreatedAuditEvent                 `json:"directory_created,omitempty"`
	DirectoryUpdated                 *DirectoryUpdatedAuditEvent                 `json:"directory_updated,omitempty"`
	DirectoryDeleted                 *DirectoryDeletedAuditEvent                 `json:"directory_deleted,omitempty"`
	DirectoryAuthorized              *DirectoryAuthorizedAuditEvent              `json:"directory_authorized,omitempty"`
	DirectorySetCredentials          *DirectorySetCredentialsAuditEvent          `json:"directory_set_credentials,omitempty"`
	DirectoryLogoUploaded            *DirectoryLogoUploadedAuditEvent            `json:"directory_logo_uploaded,omitempty"`
	DirectoryLogoDeleted             *DirectoryLogoDeletedAuditEvent             `json:"directory_logo_deleted,omitempty"`
	ConsoleSignin                    *ConsoleSigninAuditEvent                    `json:"console_signin,omitempty"`
	ConsoleSinginConfigureEmail      *ConsoleSinginConfigureEmailAuditEvent      `json:"console_singin_configure_email,omitempty"`
	ConsoleSinginConfigureSaml       *ConsoleSinginConfigureSAMLAuditEvent       `json:"console_singin_configure_saml,omitempty"`
	CliSignin                        *CLISigninAuditEvent                        `json:"cli_signin,omitempty"`
	Oauth2PushedAuthorizationRequest *OAuth2PushedAuthorizationRequestAuditEvent `json:"oauth2_pushed_authorization_request,omitempty"`
	Oauth2Authorize                  *OAuth2AuthorizeAuditEvent                  `json:"oauth2_authorize,omitempty"`
	Oauth2V2Authorize                *OAuth2V2AuthorizeAuditEvent                `json:"oauth2_v2_authorize,omitempty"`
	Oauth2RequestCanceled            *OAuth2RequestCanceledAuditEvent            `json:"oauth2_request_canceled,omitempty"`
	Oauth2Token                      *OAuth2TokenAuditEvent                      `json:"oauth2_token,omitempty"`
	EntraEamAuthorize                *EntraEamAuthorizeAuditEvent                `json:"entra_eam_authorize,omitempty"`
	EntraEamFinish                   *EntraEamFinishAuditEvent                   `json:"entra_eam_finish,omitempty"`
	OktaEamAuthorize                 *OktaEamAuthorizeAuditEvent                 `json:"okta_eam_authorize,omitempty"`
	OktaEamFinish                    *OktaEamFinishAuditEvent                    `json:"okta_eam_finish,omitempty"`
	PeopleCompare                    *PeopleCompareAuditEvent                    `json:"people_compare,omitempty"`
	SelfieCompare                    *SelfieCompareAuditEvent                    `json:"selfie_compare,omitempty"`
	SharingRevoked                   *SharingRevokedAuditEvent                   `json:"sharing_revoked,omitempty"`
	ExtensionInvoked                 *ExtensionInvokedAuditEvent                 `json:"extension_invoked,omitempty"`
}

// AuditEventKind defines model for AuditEventKind.
type AuditEventKind string

// AuthorizeRequest defines model for AuthorizeRequest.
type AuthorizeRequest struct {
	// Claim Space-separated list of claims
	Claim *[]Claim `json:"claim,omitempty"`

	// ClientId The client ID
	ClientId string `json:"client_id"`

	// CodeChallenge The code challenge
	CodeChallenge *string `json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *AuthorizeRequestCodeChallengeMethod `json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `json:"email_hint,omitempty"`

	// RedirectUri The redirect URI
	RedirectUri string `json:"redirect_uri"`

	// ResponseMode The response mode
	ResponseMode *AuthorizeRequestResponseMode `json:"response_mode,omitempty"`

	// ResponseType The response type
	ResponseType *AuthorizeRequestResponseType `json:"response_type,omitempty"`
	Return       *AuthorizeReturn              `json:"return,omitempty"`

	// Scope Space-separated list of scopes
	Scope *[]Scope `json:"scope,omitempty"`

	// State The state
	State string `json:"state"`

	// Template The template to use
	Template *string `json:"template,omitempty"`
}

// AuthorizeRequestCodeChallengeMethod The code challenge method
type AuthorizeRequestCodeChallengeMethod string

// AuthorizeRequestResponseMode The response mode
type AuthorizeRequestResponseMode string

// AuthorizeRequestResponseType The response type
type AuthorizeRequestResponseType string

// AuthorizeResponse defines model for AuthorizeResponse.
type AuthorizeResponse struct {
	ErrorMessage      string          `json:"error_message,omitempty"`
	RedirectURI       string          `json:"redirect_uri,omitempty"`
	EnvName           string          `json:"env_name,omitempty"`
	QRCode            []byte          `json:"qrcode,omitempty"`
	InstallTicket     string          `json:"install_ticket,omitempty"`
	RequestID         string          `json:"request,omitempty"`
	SessionToken      string          `json:"session_token,omitempty"`
	AppClipExperience string          `json:"app_clip_experience,omitempty"`
	Return            AuthorizeReturn `json:"return"`
}

// AuthorizeReturn defines model for AuthorizeReturn.
type AuthorizeReturn string

// AuthorizeStatus defines model for AuthorizeStatus.
type AuthorizeStatus int

// AuthorizeV2Request defines model for AuthorizeV2Request.
type AuthorizeV2Request struct {
	// RequestUri The request URI
	RequestUri string `json:"request_uri"`
}

// BadRequestResponse defines model for BadRequestResponse.
type BadRequestResponse struct {
	// Status The status code for the request. Always 400, meaning the request was invalid
	Status BadRequestResponseStatus `json:"status"`

	// Errors A set of descriptive error messages that caused the request to be invalid
	Errors []string `json:"errors"`
}

// BadRequestResponseStatus The status code for the request. Always 400, meaning the request was invalid
type BadRequestResponseStatus int

// BulkRequest defines model for BulkRequest.
type BulkRequest struct {
	// Requests A list of property requests, one for each person about whom you are requesting information.
	Requests []BulkRequestItem `json:"requests"`
}

// BulkRequestItem defines model for BulkRequestItem.
type BulkRequestItem struct {
	// Subject The subject of the request. This is the person whose properties are being requested.
	Subject string `json:"subject"`

	// Scopes Which scopes you are requesting for this person.
	Scopes *[]Scope `json:"scopes,omitempty"`

	// Claims Which claims you are requesting for this person.
	Claims []Claim `json:"claims"`
}

// BulkResponse defines model for BulkResponse.
type BulkResponse struct {
	// Responses A list of responses for each person requested.
	Responses []PropertiesResponse `json:"data"`
}

// BulkUploadAccountPhotosResponse defines model for BulkUploadAccountPhotosResponse.
type BulkUploadAccountPhotosResponse struct {
	// Files A list of responses, each corresponding to a file in the uploaded archive.
	Files []BulkUploadAccountPhotosResponseItem `json:"files"`
}

// BulkUploadAccountPhotosResponseItem defines model for BulkUploadAccountPhotosResponseItem.
type BulkUploadAccountPhotosResponseItem struct {
	// Filename The name of the file
	Filename string `json:"filename"`

	// AccountID The Nametag identifier for the account that matched this file. If this field is absent, then  the file was not matched to an existing account.
	AccountID *string `json:"account_id,omitempty"`

	// DirectoryIdentifiers The identifiers for the account used by the directory (typically an email address, username)
	DirectoryIdentifiers *[]string `json:"directory_identifiers,omitempty"`

	// DirectoryImmutableIdentifier The unchanging identifier for the account used by the directory. Most directories have a UUID or other opaque identifier that doesn't change even when `directory_identifiers` changes.
	DirectoryImmutableIdentifier *string `json:"directory_immutable_identifier,omitempty"`

	// Status This field is 200 if adding the photo was successful, 404 if an account could not be found,  400 if the image is invalid, or 422 if the image contains multiple faces, doesn't match the existing selfie, or no face at all.
	Status int `json:"status"`

	// Error A human-readable error message describing the reason a file could not be processed.
	Error *string `json:"error,omitempty"`
}

// CLISigninAuditEvent defines model for CLISigninAuditEvent.
type CLISigninAuditEvent struct {
	Session string `json:"session"`
}

// CancelResponse defines model for CancelResponse.
type CancelResponse struct {
	RedirectURI string `json:"redirect_uri"`
}

// Claim Claims are used to describe the information you want people to share with you. In order to request a claim you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
type Claim string

// CompareSelfieResult defines model for CompareSelfieResult.
type CompareSelfieResult struct {
	// Match True if the `match_confidence` exceeds Nametag's recommended threshold for a match, false otherwise.
	Match bool `json:"match"`

	// Confidence A number between 0 and 1 that represents Nametag's confidence that the values match. A value of 1 means Nametag is very confident that the values match, while 0 means that the values do not match at all.
	Confidence float64 `json:"confidence"`

	// NoFace The photo provided does not contain a person's face.
	NoFace *bool `json:"no_face,omitempty"`

	// NotMatched The face in the photo provided does not match any of the selfies on file for this person.
	NotMatched *bool `json:"not_matched,omitempty"`

	// MultipleFaces The photo provided contains more than one face.
	MultipleFaces *bool                          `json:"multiple_faces,omitempty"`
	EmployeeBadge *EmployeeBadgeValidationResult `json:"employee_badge,omitempty"`
}

// Comparison defines model for Comparison.
type Comparison struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Scope *Scope `json:"scope,omitempty"`

	// Claim Claims are used to describe the information you want people to share with you. In order to request a claim you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Claim Claim `json:"claim"`

	// Expected The expected value for this claim.
	Expected string `json:"expected"`

	// Actual The actual value for this claim.
	Actual string `json:"actual"`

	// Match True if the `match_confidence` exceeds Nametag's recommended threshold for a match, false otherwise.
	Match bool `json:"match"`

	// MatchConfidence A number between 0 and 1 that represents Nametag's confidence that the values match. A value of 1 means Nametag is very confident that the values match, while 0 means that the values do not match at all.
	MatchConfidence float64 `json:"match_confidence"`
}

// ComparisonResult defines model for ComparisonResult.
type ComparisonResult struct {
	// Confidence A number between 0 and 1 that represents Nametag's confidence that the value matches the expected value. A value of 1 means Nametag is very confident that the values match,  while 0 means that the values do not match at all.
	Confidence float64 `json:"confidence"`

	// Comparisons A list of comparisons between the expected and actual values.
	Comparisons []Comparison `json:"comparisons"`
}

// ConsoleSigninAuditEvent defines model for ConsoleSigninAuditEvent.
type ConsoleSigninAuditEvent struct {
	// Email True if the user authenticated via email
	Email *bool `json:"email,omitempty"`

	// Nametag True if the user authenticated via Nametag (deprecated)
	Nametag *bool `json:"nametag,omitempty"`

	// RelayState If the user authenticated via SAML, the RelayState parameter
	RelayState *string `json:"relay_state,omitempty"`

	// SAML True if the user authenticated via SAML
	SAML *bool `json:"saml,omitempty"`

	// SAMLResponse If the user authenticated via SAML, the RelayState parameter
	SAMLResponse *string `json:"saml_response,omitempty"`
}

// ConsoleSinginConfigureEmailAuditEvent defines model for ConsoleSinginConfigureEmailAuditEvent.
type ConsoleSinginConfigureEmailAuditEvent struct {
	Empty *bool `json:"empty,omitempty"`
}

// ConsoleSinginConfigureSAMLAuditEvent defines model for ConsoleSinginConfigureSAMLAuditEvent.
type ConsoleSinginConfigureSAMLAuditEvent struct {
	Empty *bool `json:"empty,omitempty"`
}

// CreateAPIKeyRequest defines model for CreateAPIKeyRequest.
type CreateAPIKeyRequest struct {
	// Name A descriptive name for the API key
	Name string `json:"name,omitempty"`

	// Enabled `true` if the API key is enabled, or `false` if it cannot be used.
	Enabled bool `json:"enabled,omitempty"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs"`
	Role   *Role    `json:"role,omitempty"`

	// ExpiresAt The expiration date and time for the API key. If not provided, the key will not expire. Example: "2023-12-31T23:59:59Z"
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// CreateAPIKeyResponse defines model for CreateAPIKeyResponse.
type CreateAPIKeyResponse struct {
	// ID The unique identifier for the API key
	ID string `json:"id"`

	// Key The full secret API key
	Key string `json:"key"`
}

// CreateDirectoryRequest defines model for CreateDirectoryRequest.
type CreateDirectoryRequest struct {
	// Env The ID of the environment to create this directory for
	Env string `json:"env"`

	// Kind The type of the directory connection.
	Kind        DirectoryKind `json:"kind"`
	Credentials *Credentials  `json:"credentials,omitempty"`
}

// CreateDirectoryResponse defines model for CreateDirectoryResponse.
type CreateDirectoryResponse struct {
	AgentToken *string `json:"agent_token,omitempty"`

	// ID The unique identifier for the directory.
	ID string `json:"id"`

	// RedirectURL The OAuth 2.0 redirect URL to authorize the directory.
	//
	// If the directory uses OAuth 2.0 for authorization (e.g. `"azure-ad"`), then
	// this field contains the URL to redirect the user to authorize the directory.
	RedirectURL *string `json:"redirect_url,omitempty"`
}

// CreateEnvRequest defines model for CreateEnvRequest.
type CreateEnvRequest = map[string]interface{}

// CreateEnvResponse defines model for CreateEnvResponse.
type CreateEnvResponse struct {
	// ID The unique identifier of the environment
	ID string `json:"id"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	// EnvID The ID of the environment associated with the request.
	EnvID string `json:"env"`

	// Scopes A list of the information (scopes) that the request is asking for.
	// If you specify `template`, you must not specify `scopes`.
	Scopes []Scope `json:"scopes,omitempty"`

	// Claims A list of the information (claims) that the request is asking for.
	// > **Note**: This field is required unless `template` is specified.
	Claims []Claim `json:"claims,omitempty"`

	// Template The name of a template that customizes how the request is presented to the user.
	//
	// Because a template contains its own claim definitions, you can provide either `claims` or `template`; providing both results in an amalgamation of the two.
	Template string `json:"template,omitempty"`

	// ExpiresAt The last time this request will be valid. After this time, the request is expired and the user will no longer be able to complete it. This cannot be used with `ttl`.
	ExpiresAt time.Time `json:"expires_at,omitempty"`

	// Phone The phone number to which the request link should be sent.
	Phone string `json:"phone,omitempty"`

	// Whatsapp The WhatsApp phone number to which the request link should be sent.
	Whatsapp string `json:"whatsapp,omitempty"`

	// Label An internal label for this request. You can use this field to help you track the request in your own systems. Nametag stores this field, but does not process it at all.
	Label string `json:"label,omitempty"`
}

// CreateRequestResponse defines model for CreateRequestResponse.
type CreateRequestResponse struct {
	// ID A unique identifier for the request
	ID     string               `json:"id"`
	Status NumericRequestStatus `json:"status"`

	// EnvID The ID of the environment associated with the request.
	EnvID string `json:"env"`

	// Scopes A list of the information (scopes) that the request is asking for.
	Scopes []Scope `json:"scopes"`

	// Claims A list of the information (claims) that the request is asking for.
	Claims []Claim `json:"claims"`

	// Template The name of a template that customizes how the request is presented to the user.
	Template string `json:"template,omitempty"`

	// Link An authorization link. Passing this link to the user will prompt them to complete the request.
	Link string `json:"link"`

	// Phone The phone number to which the request link was sent, in E.164 format.
	Phone string `json:"phone,omitempty"`

	// Label An internal label for this request. You can use this field to help you track the
	// request in your own systems. Nametag stores this field, but does not process it at all.
	Label string `json:"label,omitempty"`

	// ExpiresAt The last time this request will be valid. After this time, the request is expired
	// and the user will no longer be able to complete it.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// CreateTemplateRequest defines model for CreateTemplateRequest.
type CreateTemplateRequest struct {
	// Name A descriptive name of the template
	Name string `json:"name"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline *string `json:"headline,omitempty"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline *string `json:"qr_headline,omitempty"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human-readable form, e.g. "3 hours"
	ExpirationText *string `json:"expiration_text,omitempty"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText *string `json:"accept_text,omitempty"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText *string `json:"accepted_text,omitempty"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS *string `json:"install_message_sms,omitempty"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault *bool `json:"is_default,omitempty"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions,omitempty"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn *int `json:"scopes_expire_in,omitempty"`

	// ClaimDefinitions A list of claims that are requested when requests are created with this template.
	ClaimDefinitions []TemplateClaimDefinition `json:"claim_definitions,omitempty"`

	// ClaimsExpireIn How long the data sharing authorization should last, in seconds.
	ClaimsExpireIn *int `json:"claims_expire_in,omitempty"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification *bool `json:"require_selfie_reverification,omitempty"`

	// QRCustomText The text that appears below the desktop QR page headline.
	QRCustomText *string `json:"qr_custom_text,omitempty"`
}

// CreateTemplateResponse defines model for CreateTemplateResponse.
type CreateTemplateResponse struct {
	// ID The unique identifier of the template
	ID string `json:"id"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	// Account * For Duo, the integration key
	// * For Okta, this field should be blank
	// * For Onelogin, the client ID, e.g. `98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4`
	// * For BeyondIdentity, the client ID, e.g. `Tf9IGY976IqEjEHJrYSJW7JF`
	Account string `json:"account,omitempty"`

	// ApplicationID * For Duo, this field should be blank
	// * For Okta, this field should be blank
	// * For Onelogin, this field should be blank
	// * For BeyondIdentity, the application ID, e.g. `9f6b7c1e-2d44-4c2b-8c9f-3ab59e92c123`
	ApplicationID string `json:"application_id,omitempty"`

	// Partition * For Duo, the API hostname, e.g. `api-33091yc9.duosecurity.com`.
	// * For Okta, the service hostname, e.g. `your-company.okta.com`.
	// * For Onelogin, the subdomain, e.g. `example.onelogin.com`.
	// * For BeyondIdentity, the BaseURL, e.g. `https://api-us.beyondidentity.com`.
	Partition string `json:"partition"`

	// RealmID * For Duo, this field should be blank
	// * For Okta, this field should be blank
	// * For Onelogin, this field should be blank
	// * For BeyondIdentity, the realm ID, e.g. `8b4e3oxk01qwu19`
	RealmID string `json:"realm_id,omitempty"`

	// Secret * For Duo, the secret key, e.g. `cv9wJSC10XDFRGY5L9DcgHuNtR76vM8kuB1sDCpc`
	// * For Okta, the API token, e.g. `21lgux-M8uJC4w-9kN_PL0ivV5tM81AvSd7l0IuAS3`
	// * For Onelogin, the client secret, e.g. `f3d4bd80d4d4007be3455453819d3359f8a5eb2eb66fdbc7bae5e44083605118`
	// * For BeyondIdentity, the client secret, e.g. `Y0p8Q~a1Bx3K-4lHnV9zYt2sA7jRkLmF5gS9xTqW`
	Secret string `json:"secret"`

	// TenantID * For Duo, this field should be blank
	// * For Okta, this field should be blank
	// * For Onelogin, this field should be blank
	// * For BeyondIdentity, the tenant ID, e.g. `1124mn2az1yglqq`
	TenantID string `json:"tenant_id,omitempty"`
}

// Directory defines model for Directory.
type Directory struct {
	// ID The unique identifier for the directory.
	ID string `json:"id"`

	// Env The environment this directory belongs to.
	Env string `json:"env"`

	// Kind The type of the directory connection.
	Kind DirectoryKind `json:"kind"`

	// Name The internal name of the directory.
	// This field is derived from inspecting the directory itself, for example for  Entra ID this field is the primary domain name. This field is used to help you identify the directory.
	Name                      string              `json:"name"`
	AuthenticatePolicy        RecoveryPolicyRules `json:"authenticate_policy"`
	MfaPolicy                 RecoveryPolicyRules `json:"mfa_policy"`
	PasswordPolicy            RecoveryPolicyRules `json:"password_policy"`
	TemporaryAccessPassPolicy RecoveryPolicyRules `json:"temporary_access_pass_policy"`
	UnlockPolicy              RecoveryPolicyRules `json:"unlock_policy"`

	// TemporaryAccessPassLifetimeMinutes The validity period of a temporary access pass in minutes.
	// For Entra ID, this value must be between 10 and 43200 (equivalent to 30 days).  If not specified, the defaultLifetimeInMinutes setting in the  [Temporary Access Pass authentication method policy](https://learn.microsoft.com/en-us/graph/api/resources/temporaryaccesspassauthenticationmethodconfiguration?view=graph-rest-1.0) is applied.
	TemporaryAccessPassLifetimeMinutes *int `json:"temporary_access_pass_lifetime_minutes,omitempty"`

	// TemporaryAccessPassReusable True if temporary access passes can be used more than once. If unspecified,  temporary access passes are usable only once.
	TemporaryAccessPassReusable *bool               `json:"temporary_access_pass_reusable,omitempty"`
	Credentials                 *PartialCredentials `json:"credentials,omitempty"`

	// LastSyncStartedAt When the last sync started.
	LastSyncStartedAt *time.Time `json:"last_sync_started_at,omitempty"`

	// LastSyncCompletedAt When the last sync completed
	LastSyncCompletedAt *time.Time `json:"last_sync_completed_at,omitempty"`

	// LastSyncError An error describing the failure of the last sync, or null if the last sync was successful.
	LastSyncError *string `json:"last_sync_error,omitempty"`

	// Count The number of accounts in the directory.
	Count *int `json:"count,omitempty"`

	// NeedsReconnect If the directory needs to reconnect.
	NeedsReconnect *bool `json:"needs_reconnect,omitempty"`

	// SyncRunning true if the directory sync is currently running
	SyncRunning bool `json:"sync_running"`

	// BirthDateHMACSecretExists true if a shared secret for birth date HMACs has been set
	BirthDateHMACSecretExists bool `json:"birth_date_hmac_secret_exists"`

	// DirectorySecret the directory secret used by external clients for integration scenarios
	DirectorySecret []byte `json:"directory_secret,omitempty"`

	// CanGetMFABypassCode true if the directory supports generating an MFA bypass code
	CanGetMFABypassCode *bool `json:"can_get_mfa_bypass_code,omitempty"`

	// CanGetPasswordLink true if the directory supports issuing a pre-authenticated password reset link
	CanGetPasswordLink *bool `json:"can_get_password_link,omitempty"`

	// CanGetTemporaryAccessPass true if the directory supports issuing a temporary access pass
	CanGetTemporaryAccessPass *bool `json:"can_get_temporary_access_pass,omitempty"`

	// CanGetTemporaryPassword true if the directory supports issuing a temporary password
	CanGetTemporaryPassword *bool `json:"can_get_temporary_password,omitempty"`

	// CanRemoveAllMFA true if the directory supports removing all MFA devices
	CanRemoveAllMFA *bool `json:"can_remove_all_mfa,omitempty"`

	// CanUnlock true if the directory supports unlocking a locked account
	CanUnlock *bool `json:"can_unlock,omitempty"`

	// CanUpdateAccountsList true if the directory supports progressive updates to the list of accounts
	CanUpdateAccountsList *bool `json:"can_update_accounts_list,omitempty"`

	// LogoURL The URL of the logo image for this directory.
	LogoURL                    *string                     `json:"logo_url,omitempty"`
	RecoveryOperationRateLimit *RecoveryOperationRateLimit `json:"recovery_operation_rate_limit,omitempty"`
}

// DirectoryAuthorizedAuditEvent defines model for DirectoryAuthorizedAuditEvent.
type DirectoryAuthorizedAuditEvent struct {
	Directory string `json:"directory"`
}

// DirectoryCreatedAuditEvent defines model for DirectoryCreatedAuditEvent.
type DirectoryCreatedAuditEvent struct {
	Request  CreateDirectoryRequest  `json:"request"`
	Response CreateDirectoryResponse `json:"response"`
}

// DirectoryDeletedAuditEvent defines model for DirectoryDeletedAuditEvent.
type DirectoryDeletedAuditEvent struct {
	Directory string `json:"directory"`
}

// DirectoryGroup defines model for DirectoryGroup.
type DirectoryGroup struct {
	// DirectoryImmutableIdentifier The unique identifier for the group.
	DirectoryImmutableIdentifier string `json:"directory_immutable_identifier"`

	// Name The display name of the group.
	Name string `json:"name"`
}

// DirectoryKind The type of the directory connection.
type DirectoryKind string

// DirectoryLogoDeletedAuditEvent defines model for DirectoryLogoDeletedAuditEvent.
type DirectoryLogoDeletedAuditEvent struct {
	Directory string `json:"directory"`
}

// DirectoryLogoUploadedAuditEvent defines model for DirectoryLogoUploadedAuditEvent.
type DirectoryLogoUploadedAuditEvent struct {
	Directory string `json:"directory"`
}

// DirectorySetCredentialsAuditEvent defines model for DirectorySetCredentialsAuditEvent.
type DirectorySetCredentialsAuditEvent struct {
	Directory string `json:"directory"`
}

// DirectoryUpdatedAuditEvent defines model for DirectoryUpdatedAuditEvent.
type DirectoryUpdatedAuditEvent struct {
	Directory string                 `json:"directory"`
	Request   UpdateDirectoryRequest `json:"request"`
}

// EmployeeBadgeValidationResult defines model for EmployeeBadgeValidationResult.
type EmployeeBadgeValidationResult struct {
	// Valid True if the photo is appropriate for use as an employee badge, false otherwise.
	Valid bool `json:"valid"`

	// Reason If the photo is not appropriate for use as an employee badge, a human-readable explanation of why the photo is not valid.
	Reason *string `json:"reason,omitempty"`
}

// EncryptSecretRequest defines model for EncryptSecretRequest.
type EncryptSecretRequest struct {
	// Plaintext The secret to encrypt
	Plaintext string `json:"plaintext"`
}

// EncryptSecretResponse defines model for EncryptSecretResponse.
type EncryptSecretResponse struct {
	// Ciphertext The encrypted secret value
	Ciphertext string `json:"ciphertext"`
}

// EntraEamAuthorizeAuditEvent defines model for EntraEamAuthorizeAuditEvent.
type EntraEamAuthorizeAuditEvent struct {
	Directory string                    `json:"directory"`
	Request   EntraEamAuthorizeRequest  `json:"request"`
	Response  EntraEamAuthorizeResponse `json:"response"`
}

// EntraEamAuthorizeRequest defines model for EntraEamAuthorizeRequest.
type EntraEamAuthorizeRequest struct {
	Claims          string `json:"claims"`
	ClientId        string `json:"client_id"`
	ClientRequestId string `json:"client_request_id"`
	IdTokenHint     string `json:"id_token_hint"`
	Nonce           string `json:"nonce"`
	RedirectUri     string `json:"redirect_uri"`
	ResponseMode    string `json:"response_mode"`
	ResponseType    string `json:"response_type"`
	Scope           string `json:"scope"`
	State           string `json:"state"`
}

// EntraEamAuthorizeResponse defines model for EntraEamAuthorizeResponse.
type EntraEamAuthorizeResponse struct {
	Oauth2ClientId    string `json:"oauth2_client_id"`
	Oauth2RedirectUri string `json:"oauth2_redirect_uri"`
	Oauth2Server      string `json:"oauth2_server"`
	Oauth2Template    string `json:"oauth2_template"`
	State             string `json:"state"`
}

// EntraEamFinishAuditEvent defines model for EntraEamFinishAuditEvent.
type EntraEamFinishAuditEvent struct {
	Directory string                 `json:"directory"`
	Request   EntraEamFinishRequest  `json:"request"`
	Response  EntraEamFinishResponse `json:"response"`
}

// EntraEamFinishRequest defines model for EntraEamFinishRequest.
type EntraEamFinishRequest struct {
	Code  *string `json:"code,omitempty"`
	Error *string `json:"error,omitempty"`
	State string  `json:"state"`
}

// EntraEamFinishResponse defines model for EntraEamFinishResponse.
type EntraEamFinishResponse struct {
	BindingFailed *bool   `json:"binding_failed,omitempty"`
	Error         *string `json:"error,omitempty"`
	IDToken       *string `json:"id_token,omitempty"`
	Oauth2State   *string `json:"oauth2_state,omitempty"`
	RedirectUri   *string `json:"redirect_uri,omitempty"`
}

// Env defines model for Env.
type Env struct {
	// ID The identifier for this environment
	ID string `json:"id"`

	// Name The internal name for this environment
	Name string `json:"name"`

	// PublicName The name of the environment that is shared with people
	PublicName string `json:"public_name"`

	// LogoURL A URL to your logo, which is displayed in the Nametag mobile app.
	LogoURL string `json:"logo_url"`

	// TermsOfServiceURL The URL of the terms of service.
	//
	// Formerly, this URL was provided to end-users in the Nametag mobile app, but it
	// is no longer used.
	// Deprecated:
	TermsOfServiceURL string `json:"terms_of_service_url"`

	// CallbackURLs A list of valid URLs for use as OAuth 2.0 callback URLs.
	CallbackURLs []string `json:"callback_urls"`

	// Webhooks A list of webhooks.
	Webhooks []WebhookDefinition `json:"webhooks"`

	// Templates A list of request templates.
	Templates []Template  `json:"templates"`
	Storage   *EnvStorage `json:"storage,omitempty"`

	// OidcDelegates A list of OIDC Delegates.
	OidcDelegates []OIDCDelegate `json:"oidc_delegates"`

	// MicrositeSAMLDirectories A list of directory ID's that back the SAML verify flow.
	MicrositeSAMLDirectories []string `json:"microsite_saml_directories"`
}

// EnvCreatedAuditEvent defines model for EnvCreatedAuditEvent.
type EnvCreatedAuditEvent struct {
	Request  CreateEnvRequest  `json:"request"`
	Response CreateEnvResponse `json:"response"`
}

// EnvDeletedAuditEvent defines model for EnvDeletedAuditEvent.
type EnvDeletedAuditEvent struct {
	Empty *bool `json:"empty,omitempty"`
}

// EnvLogoDeletedAuditEvent defines model for EnvLogoDeletedAuditEvent.
type EnvLogoDeletedAuditEvent struct {
	Kind string `json:"kind"`
}

// EnvLogoUploadedAuditEvent defines model for EnvLogoUploadedAuditEvent.
type EnvLogoUploadedAuditEvent struct {
	Kind string `json:"kind"`
}

// EnvStatusFilterParams defines model for EnvStatusFilterParams.
type EnvStatusFilterParams string

// EnvStorage defines model for EnvStorage.
type EnvStorage struct {
	// S3BucketUS The S3 bucket for data stored in the United States. Must be in the us-east-2 AWS region.
	S3BucketUS *string `json:"s3_bucket_us,omitempty"`

	// S3BucketEU The S3 bucket for data stored in Europe. Must be in the eu-west-1 AWS region.
	S3BucketEU *string `json:"s3_bucket_eu,omitempty"`

	// S3BucketIN The S3 bucket for data stored in India. Must be in the ap-south-1 AWS region.
	S3BucketIN *string `json:"s3_bucket_in,omitempty"`

	// AWSRoleARN The role Nametag should use to access the S3 buckets.
	AWSRoleARN *string `json:"aws_role_arn,omitempty"`

	// AzureBlobSasUS Azure Blob Storage presigned (SAS) URL. Should be in the eastus region.
	AzureBlobSasUS *string `json:"azure_blob_us,omitempty"`

	// AzureBlobSasEU Azure Blob Storage presigned (SAS) URL. Should be in the northeurope region.
	AzureBlobSasEU *string `json:"azure_blob_eu,omitempty"`

	// AzureBlobSasIN Azure Blob Storage presigned (SAS) URL. Should be in the centralindia region.
	AzureBlobSasIN *string `json:"azure_blob_in,omitempty"`
}

// EnvUpdateRequest defines model for EnvUpdateRequest.
type EnvUpdateRequest struct {
	// Name Update the name of the environment, for internal use.
	Name *string `json:"name,omitempty"`

	// PublicName Update the public-facing name for your environment, typically your company or brand name.
	PublicName *string `json:"public_name,omitempty"`

	// CallbackURLs Set the list of allowed OAuth 2.0 callback URLs
	CallbackURLs []string `json:"callback_urls,omitempty"`

	// TermsOfServiceURL Update the terms of service URL.
	// Deprecated:
	TermsOfServiceURL *string `json:"terms_of_service_url,omitempty"`

	// RemoveWebhooks Remove webhooks from the environment (IDs of the webhooks to remove)
	RemoveWebhooks []string `json:"remove_webhooks,omitempty"`

	// AddWebhooks Add webhooks to the environment
	AddWebhooks   []WebhookDefinition      `json:"add_webhooks,omitempty"`
	UpdateWebhook *WebhookDefinitionUpdate `json:"update_webhook,omitempty"`
	Storage       *EnvStorage              `json:"storage,omitempty"`

	// RemoveOidcDelegates Remove OIDC delegate from the environment (IDs of the delegates to remove)
	RemoveOidcDelegates []string `json:"remove_oidc_delegates,omitempty"`

	// AddOidcDelegates Add OIDC delegates to the environment
	AddOidcDelegates   []OIDCDelegate      `json:"add_oidc_delegates,omitempty"`
	UpdateOidcDelegate *OIDCDelegateUpdate `json:"update_oidc_delegate,omitempty"`
}

// EnvUpdatedAtFilterParams defines model for EnvUpdatedAtFilterParams.
type EnvUpdatedAtFilterParams string

// EnvUpdatedAuditEvent defines model for EnvUpdatedAuditEvent.
type EnvUpdatedAuditEvent struct {
	Request EnvUpdateRequest `json:"request"`
}

// EnvWebhookSecretUpdatedAuditEvent defines model for EnvWebhookSecretUpdatedAuditEvent.
type EnvWebhookSecretUpdatedAuditEvent struct {
	Empty *bool `json:"empty,omitempty"`
}

// Expectation defines model for Expectation.
type Expectation struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Scope *Scope `json:"scope,omitempty"`

	// Claim Claims are used to describe the information you want people to share with you. In order to request a claim you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Claim Claim `json:"claim"`

	// Value The value you expect the person to have for this claim.
	Value string `json:"value"`
}

// ExtensionInvokedAuditEvent defines model for ExtensionInvokedAuditEvent.
type ExtensionInvokedAuditEvent struct {
	// Method The extension method name
	Method string `json:"method"`

	// Logs Messages that are emitted by console logs during the execution of the extension  function.
	Logs []string `json:"logs,omitempty"`

	// Error If the extension method returned an error, this will contain the error message. Otherwise, it will be empty.
	Error *string `json:"error,omitempty"`
}

// GetDirectoriesResponse defines model for GetDirectoriesResponse.
type GetDirectoriesResponse struct {
	// Directories A list of all directories.
	Directories []Directory `json:"directories"`
}

// GetMicrometricsResponse defines model for GetMicrometricsResponse.
type GetMicrometricsResponse struct {
	// SelfServiceCount Number of self-service requests
	SelfServiceCount int64 `json:"self_service_count"`

	// VerificationCount Total number of verification requests
	VerificationCount int64 `json:"verification_count"`

	// FraudCount Number of fraud requests
	FraudCount int64 `json:"fraud_count"`

	// HumansVerifiedCount Number of humans verified
	HumansVerifiedCount int64 `json:"humans_verified_count"`

	// ApiRequestsCount Number of API requests
	ApiRequestsCount int64 `json:"api_requests_count"`

	// CopilotCount Number of Copilot requests
	CopilotCount int64 `json:"copilot_count"`
}

// GetRequestsResponse defines model for GetRequestsResponse.
type GetRequestsResponse struct {
	Requests         []Request `json:"requests"`
	NextOffset       int       `json:"next_offset"`
	TotalResultCount int64     `json:"total_result_count"`
}

// GovtidType defines model for GovtidType.
type GovtidType string

// GovtidValue defines model for GovtidValue.
type GovtidValue struct {
	Type GovtidType `json:"type"`

	// Issuer The issuer of the identity document, an  [ISO 3166-1 alpha 3 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) optionally followed by  a jurisdiction code, e.g. `USA.CA` or `CAN.ON`
	Issuer *string `json:"issuer,omitempty"`

	// DocumentNumber The unique number of the identity document
	DocumentNumber *string `json:"document_number,omitempty"`

	// Expiration The date when the identity document expires
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
}

// GroupRecoveryPolicy defines model for GroupRecoveryPolicy.
type GroupRecoveryPolicy struct {
	Group  DirectoryGroup `json:"group"`
	Policy RecoveryPolicy `json:"policy"`
}

// InviteOrgMemberRequest defines model for InviteOrgMemberRequest.
type InviteOrgMemberRequest struct {
	// Email The email address of the person you want to invite.
	Email openapi_types.Email `json:"email"`

	// Envs The list of environments the member will have access to. If the list contains `*`, the member will have access to all environments.
	Envs []string `json:"envs"`
	Role Role     `json:"role"`
}

// ListAPIKeysResponse defines model for ListAPIKeysResponse.
type ListAPIKeysResponse struct {
	// APIKeys A list of API keys
	APIKeys []APIKey `json:"apikeys"`
}

// ListAuditEventsResponse defines model for ListAuditEventsResponse.
type ListAuditEventsResponse struct {
	// Events A list of audit events
	Events         []AuditEvent `json:"events"`
	BackwardCursor *string      `json:"backward_cursor,omitempty"`
	ForwardCursor  *string      `json:"forward_cursor,omitempty"`
}

// ListEnvsResponse defines model for ListEnvsResponse.
type ListEnvsResponse struct {
	// Envs A list of all your environments.
	Envs []Env `json:"envs"`
}

// ListOrgMembersResponse defines model for ListOrgMembersResponse.
type ListOrgMembersResponse struct {
	// Members A list of each member of the organization
	Members []OrgMember `json:"members"`
}

// ListSlackIntegrationsResponse defines model for ListSlackIntegrationsResponse.
type ListSlackIntegrationsResponse struct {
	// Integrations A list of Slack integrations for this environment
	Integrations []SlackIntegration `json:"integrations"`
}

// ListWebhooksResponse defines model for ListWebhooksResponse.
type ListWebhooksResponse struct {
	Webhooks []Webhook `json:"webhooks"`
}

// Location defines model for Location.
type Location struct {
	// Business Whether the location is a business.
	Business bool `json:"business,omitempty"`

	// City The city of the location.
	City string `json:"city,omitempty"`

	// Country The country of the location.
	Country string `json:"country,omitempty"`

	// Latitude The latitude of the location.
	Latitude float64 `json:"latitude"`

	// Longitude The longitude of the location.
	Longitude float64 `json:"longitude"`

	// PoBox Whether the location is a PO box.
	PoBox bool `json:"po_box,omitempty"`

	// Residential Whether the location is residential.
	Residential bool `json:"residential,omitempty"`

	// Subdivision The subdivision of the location (e.g. the state or province).
	Subdivision string `json:"subdivision,omitempty"`
}

// LogoKind defines model for LogoKind.
type LogoKind string

// NumericRequestStatus defines model for NumericRequestStatus.
type NumericRequestStatus int

// OAuth2AuthorizeAuditEvent defines model for OAuth2AuthorizeAuditEvent.
type OAuth2AuthorizeAuditEvent struct {
	Request  AuthorizeRequest  `json:"request"`
	Response AuthorizeResponse `json:"response"`
}

// OAuth2AuthorizeResponse defines model for OAuth2AuthorizeResponse.
type OAuth2AuthorizeResponse struct {
	// RedirectURL The URL to redirect the user to authorize the directory.
	RedirectURL string `json:"redirect_url"`
}

// OAuth2PushedAuthorizationRequestAuditEvent defines model for OAuth2PushedAuthorizationRequestAuditEvent.
type OAuth2PushedAuthorizationRequestAuditEvent struct {
	Request  PushedAuthorizationRequest  `json:"request"`
	Response PushedAuthorizationResponse `json:"response"`
}

// OAuth2RequestCanceledAuditEvent defines model for OAuth2RequestCanceledAuditEvent.
type OAuth2RequestCanceledAuditEvent struct {
	Request string `json:"request"`
}

// OAuth2TokenAuditEvent defines model for OAuth2TokenAuditEvent.
type OAuth2TokenAuditEvent struct {
	Request  TokenRequest  `json:"request"`
	Response TokenResponse `json:"response"`
}

// OAuth2V2AuthorizeAuditEvent defines model for OAuth2V2AuthorizeAuditEvent.
type OAuth2V2AuthorizeAuditEvent struct {
	Request  AuthorizeV2Request `json:"request"`
	Response AuthorizeResponse  `json:"response"`
}

// OIDCDelegate defines model for OIDCDelegate.
type OIDCDelegate struct {
	// ID A unique identifier for the OIDC delegate.
	ID string `json:"id"`

	// Name The name of the delegate
	Name string `json:"name"`

	// ClientID The client ID for the OAuth delegate.
	ClientID *string `json:"client_id,omitempty"`

	// ClientSecret The client secret for the OAuth delegate.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Issuer The URL of the issuer for the OIDC delegate.
	Issuer string `json:"issuer"`
}

// OIDCDelegateUpdate defines model for OIDCDelegateUpdate.
type OIDCDelegateUpdate struct {
	ID           string  `json:"id"`
	Name         *string `json:"name,omitempty"`
	ClientID     *string `json:"client_id,omitempty"`
	ClientSecret *string `json:"client_secret,omitempty"`
	Issuer       *string `json:"issuer,omitempty"`
}

// OktaEamAuthorizeAuditEvent defines model for OktaEamAuthorizeAuditEvent.
type OktaEamAuthorizeAuditEvent struct {
	Directory string                   `json:"directory"`
	Request   OktaEamAuthorizeRequest  `json:"request"`
	Response  OktaEamAuthorizeResponse `json:"response"`
}

// OktaEamAuthorizeRequest defines model for OktaEamAuthorizeRequest.
type OktaEamAuthorizeRequest struct {
	Claims       string `json:"claims"`
	ClientId     string `json:"client_id"`
	LoginHint    string `json:"login_hint"`
	RedirectUri  string `json:"redirect_uri"`
	ResponseType string `json:"response_type"`
	Scope        string `json:"scope"`
	State        string `json:"state"`
}

// OktaEamAuthorizeResponse defines model for OktaEamAuthorizeResponse.
type OktaEamAuthorizeResponse struct {
	Oauth2ClientId    string `json:"oauth2_client_id"`
	Oauth2RedirectUri string `json:"oauth2_redirect_uri"`
	Oauth2Server      string `json:"oauth2_server"`
	Oauth2Template    string `json:"oauth2_template"`
	State             string `json:"state"`
}

// OktaEamFinishAuditEvent defines model for OktaEamFinishAuditEvent.
type OktaEamFinishAuditEvent struct {
	Directory string                `json:"directory"`
	Request   OktaEamFinishRequest  `json:"request"`
	Response  OktaEamFinishResponse `json:"response"`
}

// OktaEamFinishRequest defines model for OktaEamFinishRequest.
type OktaEamFinishRequest struct {
	Code  *string `json:"code,omitempty"`
	Error *string `json:"error,omitempty"`
	State string  `json:"state"`
}

// OktaEamFinishResponse defines model for OktaEamFinishResponse.
type OktaEamFinishResponse struct {
	BindingFailed  *bool   `json:"binding_failed,omitempty"`
	Code           *string `json:"code,omitempty"`
	Error          *string `json:"error,omitempty"`
	IDToken        *string `json:"id_token,omitempty"`
	Oauth2State    *string `json:"oauth2_state,omitempty"`
	RedirectUri    *string `json:"redirect_uri,omitempty"`
	RequestTimeout *bool   `json:"request_timeout,omitempty"`
}

// Org defines model for Org.
type Org struct {
	// Name The name of the organization, typically the name of your company
	Name string `json:"name"`
	Role Role   `json:"role"`

	// Envs A list of the environment IDs that you have access to.
	Envs []string `json:"envs"`
}

// OrgMember defines model for OrgMember.
type OrgMember struct {
	// MemberID A unique identifier of the member.
	MemberID string `json:"member_id"`
	Role     Role   `json:"role"`

	// Envs The list of environments the member has access to. If the list contains `*`, the member has access to all  environments.
	Envs []string `json:"envs"`

	// Name The name of the member.
	Name string `json:"name"`

	// Email The email address of the member.
	Email string `json:"email"`

	// ProfilePicture The URL of the profile picture of the member.
	ProfilePicture string `json:"profile_picture"`

	// InvitePending True if the member has been invited to the organization but has not  yet signed in.
	InvitePending bool `json:"invite_pending"`

	// RequestsCount The number of requests the member has sent.
	RequestsCount *int `json:"requests_count,omitempty"`

	// Principal The principal of this org member
	Principal string `json:"principal"`
}

// OrgMemberInvitedAuditEvent defines model for OrgMemberInvitedAuditEvent.
type OrgMemberInvitedAuditEvent struct {
	Request InviteOrgMemberRequest `json:"request"`
}

// OrgMemberRemovedAuditEvent defines model for OrgMemberRemovedAuditEvent.
type OrgMemberRemovedAuditEvent struct {
	OrgMember string `json:"org_member"`
}

// OrgMemberUpdatedAuditEvent defines model for OrgMemberUpdatedAuditEvent.
type OrgMemberUpdatedAuditEvent struct {
	OrgMember string                 `json:"org_member"`
	Request   UpdateOrgMemberRequest `json:"request"`
}

// OrgUpdateRequest defines model for OrgUpdateRequest.
type OrgUpdateRequest struct {
	// Name The name of the organization, typically the name of your company
	Name               *string   `json:"name,omitempty"`
	AllowedIPAddresses *[]string `json:"allowed_ip_addresses,omitempty"`
}

// OrgUpdatedAuditEvent defines model for OrgUpdatedAuditEvent.
type OrgUpdatedAuditEvent struct {
	Request OrgUpdateRequest `json:"request"`
}

// PartialCredentials defines model for PartialCredentials.
type PartialCredentials struct {
	// Account * For Duo, the integration key
	// * For Okta, this field should be blank
	// * For Onelogin, the client ID, e.g. `98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4`
	Account string `json:"account"`

	// Partition * For Duo, the API hostname, e.g. `api-33091yc9.duosecurity.com`.
	// * For Okta, the service hostname, e.g. `your-company.okta.com`.
	// * For Onelogin, the subdomain, e.g. `example.onelogin.com`.
	Partition string `json:"partition"`
}

// PeopleCompareAuditEvent defines model for PeopleCompareAuditEvent.
type PeopleCompareAuditEvent struct {
	Request  SubjectComparisonRequest `json:"request"`
	Response ComparisonResult         `json:"response"`
}

// PollResponse defines model for PollResponse.
type PollResponse struct {
	Status           AuthorizeStatus `json:"status"`
	RedirectURI      string          `json:"redirect_uri,omitempty"`
	WaitingForReview bool            `json:"waiting_for_review,omitempty"`
	LastEvent        interface{}     `json:"last_event,omitempty"`
}

// Principal defines model for Principal.
type Principal struct {
	Role Role `json:"role"`

	// OrgMember The ID of the OrgMember for the console user performing the action
	OrgMember *string `json:"org_member,omitempty"`

	// OrgMemberEmail The email address associated with the OrgMember
	OrgMemberEmail *string `json:"org_member_email,omitempty"`

	// APIKeyID The ID of the APIKey for the actor performing the action.
	APIKeyID *string `json:"api_key,omitempty"`

	// Impersonator Present if the request was made by a Nametag administrator on behalf of the  user. The value is the email address of the Nametag administrator performing  the action.
	Impersonator *string `json:"impersonator,omitempty"`

	// Subject If the request was authenticated using an ID token, then this is the subject of the ID token.
	Subject *string `json:"subject,omitempty"`
}

// PropertiesResponse defines model for PropertiesResponse.
type PropertiesResponse struct {
	// Subject The subject of the request. This is the person whose properties are being requested.
	Subject string `json:"subject"`

	// Requests The requests that were made to get the properties.
	Requests []PropertyResponseRequest `json:"requests"`

	// Properties Properties of the person.
	Properties []PropertyResponse `json:"properties"`
}

// PropertyResponse defines model for PropertyResponse.
type PropertyResponse struct {
	// Expires When your access to this data expires
	Expires string `json:"expires,omitempty"`

	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Scope *Scope `json:"scope,omitempty"`

	// Claim Claims are used to describe the information you want people to share with you. In order to request a claim you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Claim Claim `json:"claim"`

	// Value The value of the property. The type of this field varies depending on the claim. See [this table](#scopes).
	Value interface{} `json:"value,omitempty"`

	// Status A value that tells you the disposition of the property. The value `200` means the data was shared.  The value `403` means the data has not been shared, the person has revoked your access, or `410` meaning  the request has expired.
	Status int `json:"status"`
}

// PropertyResponseRequest defines model for PropertyResponseRequest.
type PropertyResponseRequest struct {
	// ID A unique identifier for the request.
	ID string `json:"id"`

	// CreatedAt The time that the request was initiated
	CreatedAt time.Time `json:"created_at"`

	// Status The status of the request, 200 means accepted, 403 means rejected or canceled.
	Status int `json:"status"`

	// Scopes The scopes requested
	Scopes *[]Scope `json:"scopes,omitempty"`

	// Claims The claims requested
	Claims []Claim `json:"claims"`
}

// PushedAuthorizationRequest defines model for PushedAuthorizationRequest.
type PushedAuthorizationRequest struct {
	// Claim Space-separated list of claims
	Claim *[]Claim `json:"claim,omitempty"`

	// ClientId The client ID
	ClientId string `json:"client_id"`

	// ClientSecret The client secret
	ClientSecret string `json:"client_secret"`

	// CodeChallenge The code challenge
	CodeChallenge *string `json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *PushedAuthorizationRequestCodeChallengeMethod `json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `json:"email_hint,omitempty"`

	// ExpirySeconds The expiration time in seconds for the PAR
	ExpirySeconds *int `json:"expiry_seconds,omitempty"`

	// RedirectUri The redirect URI
	RedirectUri string `json:"redirect_uri"`

	// ResponseMode The response mode
	ResponseMode *PushedAuthorizationRequestResponseMode `json:"response_mode,omitempty"`

	// ResponseType The response type
	ResponseType *PushedAuthorizationRequestResponseType `json:"response_type,omitempty"`
	Return       *AuthorizeReturn                        `json:"return,omitempty"`

	// Scope Space-separated list of scopes
	Scope *[]Scope `json:"scope,omitempty"`

	// State The state
	State string `json:"state"`

	// Template The template to use
	Template *string `json:"template,omitempty"`
}

// PushedAuthorizationRequestCodeChallengeMethod The code challenge method
type PushedAuthorizationRequestCodeChallengeMethod string

// PushedAuthorizationRequestResponseMode The response mode
type PushedAuthorizationRequestResponseMode string

// PushedAuthorizationRequestResponseType The response type
type PushedAuthorizationRequestResponseType string

// PushedAuthorizationResponse defines model for PushedAuthorizationResponse.
type PushedAuthorizationResponse struct {
	RequestURI string `json:"request_uri"`
	ExpiresIn  int    `json:"expires_in"`
}

// RecoveryMicrositeFlow defines model for RecoveryMicrositeFlow.
type RecoveryMicrositeFlow string

// RecoveryMicrositeOperation defines model for RecoveryMicrositeOperation.
type RecoveryMicrositeOperation string

// RecoveryMicrositePresignRequest defines model for RecoveryMicrositePresignRequest.
type RecoveryMicrositePresignRequest struct {
	// Email The email address or identifier of the account. Use `*` to allow the presigned URL
	// to apply to any account.
	Email *string `json:"email,omitempty"`

	// Ttl The duration for which the presigned URL is valid. The duration is specified as a string
	// in the format `1h30m` for 1 hour and 30 minutes, or `1m20s` for 1 minute and 20 seconds.
	Ttl jsonx.Duration `json:"ttl"`

	// Operations The operations that the presigned URL should allow.
	Operations *[]RecoveryMicrositeOperation `json:"operations,omitempty"`

	// Directories The identifiers of the directories that the presigned URL should apply to.
	Directories *[]string              `json:"directories,omitempty"`
	Flow        *RecoveryMicrositeFlow `json:"flow,omitempty"`
}

// RecoveryMicrositePresignResponse defines model for RecoveryMicrositePresignResponse.
type RecoveryMicrositePresignResponse struct {
	Url string `json:"url"`
}

// RecoveryOperationRateLimit defines model for RecoveryOperationRateLimit.
type RecoveryOperationRateLimit struct {
	// Count The number of operations allowed in the window.
	Count int `json:"count"`

	// Window The duration of the window. The duration is specified as a string
	// in the format `1h30m` for 1 hour and 30 minutes, or `1m20s` for 1 minute and 20 seconds.
	Window jsonx.Duration `json:"window"`
}

// RecoveryPolicy defines model for RecoveryPolicy.
type RecoveryPolicy string

// RecoveryPolicyRules defines model for RecoveryPolicyRules.
type RecoveryPolicyRules struct {
	// Groups A list of policies to apply based on an Account's group membership.
	// When Nametag evaluates policy, the first entry in this list that matches will be applied. If no group matches, then the default policy is applied.
	Groups  []GroupRecoveryPolicy `json:"groups"`
	Default RecoveryPolicy        `json:"default"`
}

// RefreshWebhookSecretRequest defines model for RefreshWebhookSecretRequest.
type RefreshWebhookSecretRequest struct {
	// EnvID The environment identifier for which the webhook secret is to be refreshed
	EnvID string `json:"envID"`
}

// RefreshWebhookSecretResponse defines model for RefreshWebhookSecretResponse.
type RefreshWebhookSecretResponse struct {
	// WebhookSharedSecret The new webhook shared secret
	WebhookSharedSecret string `json:"webhook_shared_secret"`
}

// RegenerateDirectoryAgentTokenResponse defines model for RegenerateDirectoryAgentTokenResponse.
type RegenerateDirectoryAgentTokenResponse struct {
	AgentToken string `json:"agent_token"`

	// ID The unique identifier for the directory.
	ID string `json:"id"`
}

// Request defines model for Request.
type Request struct {
	// ID A unique identifier for this request
	ID string `json:"id"`

	// CreatedAt Timestamp of when this request was created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt Timestamp of the last time this request was updated
	UpdatedAt time.Time `json:"updated_at"`

	// ExpiresAt Timestamp of when this request expires
	ExpiresAt time.Time `json:"expires_at"`

	// Ticket The request ticket (used to construct the link)
	Ticket string `json:"ticket"`

	// Link The URL which should be sent to the user. This link launches the mobile app and prompts the user to verify their identity.
	Link string `json:"link"`

	// Phone The phone number that will receive an authorization link via SMS
	Phone *string `json:"phone,omitempty"`

	// Env The ID of the environment associated with the request
	Env      string `json:"env"`
	Template string `json:"template"`

	// Label The label for the request; can be empty
	Label    string          `json:"label"`
	Scopes   []Scope         `json:"scopes"`
	Claims   []Claim         `json:"claims"`
	Status   RequestStatus   `json:"status"`
	Progress RequestProgress `json:"progress"`

	// Subject The subject of the request. Present only when `status` is `shared`. Use this as a parameter to [the properties endpoint](#get-properties) to fetch the data shared.
	Subject *string `json:"subject,omitempty"`

	// SubjectText A description of the subject (e.g. their name or email address) suitable for presentation in a user interface.
	SubjectText *string `json:"subject_text,omitempty"`

	// Requester The [member ID](#OrgMember) of the user that created this request. This field is absent for requests created via the API.
	Requester *string `json:"requester,omitempty"`

	// RequesterText A description of the requester suitable for presentation in a user interface (e.g. their name or email address)
	RequesterText *string              `json:"requester_text,omitempty"`
	Properties    RequestProperties    `json:"properties"`
	Mobile        *RequestMobileDevice `json:"mobile,omitempty"`
	Browser       *RequestBrowser      `json:"browser,omitempty"`

	// IsKnownUser If the user is known as an account
	IsKnownUser *bool `json:"is_known_user,omitempty"`

	// Photo The photo associated with this person
	Photo *string `json:"photo,omitempty"`

	// ExternalIds External IDs for accounts if the user is known
	ExternalIds *[]string `json:"external_ids,omitempty"`

	// MarkedForDeletionAfter Indicates whether the person associated with this request has asked for their data to be deleted and the earliest time that will occur at.
	MarkedForDeletionAfter *time.Time                 `json:"marked_for_deletion_after,omitempty"`
	VerificationSource     *RequestVerificationSource `json:"verification_source,omitempty"`
}

// RequestBrowser defines model for RequestBrowser.
type RequestBrowser struct {
	// UserAgent The browser's user agent
	UserAgent string `json:"user_agent"`

	// RemoteAddress The IP address of the browser  (This field is `null` unless the `location:ip` claim is specified in the request)
	RemoteAddress         *string   `json:"remote_address,omitempty"`
	RemoteAddressLocation *Location `json:"remote_address_location,omitempty"`
}

// RequestCanceledAuditEvent defines model for RequestCanceledAuditEvent.
type RequestCanceledAuditEvent struct {
	RequestID string `json:"request_id"`
}

// RequestCreatedAuditEvent defines model for RequestCreatedAuditEvent.
type RequestCreatedAuditEvent struct {
	Request  CreateRequestRequest  `json:"request"`
	Response CreateRequestResponse `json:"response"`
}

// RequestMobileDevice defines model for RequestMobileDevice.
type RequestMobileDevice struct {
	// OS The full operating system name and version of the mobile device
	OS string `json:"os"`

	// Version The version of the Nametag app
	Version string `json:"version"`

	// IOS `true` if the device is an iOS device, otherwise `false`
	IOS bool `json:"ios"`

	// Android `true` if the device is an Android device, otherwise `false`
	Android bool `json:"android"`

	// FullApp `true` if the request was completed in the full Nametag app, otherwise `false`
	FullApp bool `json:"full_app"`

	// AppClip `true` if the request was completed in the iOS app clip, otherwise `false`
	AppClip bool `json:"app_clip"`

	// InstantApp `true` if the request was completed in the Android instant app, otherwise `false`
	InstantApp bool `json:"instant_app"`

	// RemoteAddress The IP address of the mobile device (This field is `null` unless the `location:ip` claim is specified in the request)
	RemoteAddress         *string   `json:"remote_address,omitempty"`
	RemoteAddressLocation *Location `json:"remote_address_location,omitempty"`
}

// RequestProgress defines model for RequestProgress.
type RequestProgress string

// RequestProperties defines model for RequestProperties.
type RequestProperties struct {
	// Phone The person's phone number
	Phone *string `json:"phone,omitempty"`

	// LegalName The person's name from their identity document
	LegalName *string `json:"legal_name,omitempty"`

	// LegalFirstName The given name (first name) from their identity document
	LegalFirstName *string `json:"legal_first_name,omitempty"`

	// LegalLastName The family name (last name) from their identity document
	LegalLastName *string `json:"legal_last_name,omitempty"`

	// Name The person's name from their identity document
	Name *string `json:"name,omitempty"`

	// FirstName The person's given (first) name from their identity document
	FirstName *string `json:"first_name,omitempty"`

	// LastName The person's family (last) name from their identity document
	LastName *string `json:"last_name,omitempty"`

	// BirthDate The person's date of birth
	BirthDate *openapi_types.Date `json:"birth_date,omitempty"`

	// Email Verified email address
	Email *openapi_types.Email `json:"email,omitempty"`

	// UnverifiedEmail The email address provided by a user but not verified
	UnverifiedEmail *openapi_types.Email `json:"unverified_email,omitempty"`

	// AgeOver18 `true` if the person is over 18 years old, otherwise `false`
	AgeOver18 *bool `json:"age_over_18,omitempty"`

	// AgeOver21 `true` if the person is over 21 years old, otherwise `false`
	AgeOver21 *bool `json:"age_over_21,omitempty"`

	// ProfilePicture A URL to the person's preferred profile picture. Nametag checks that the image provided is the same person as pictured on their identity document.
	ProfilePicture *string `json:"profile_picture,omitempty"`

	// Address Verified postal address
	Address *string      `json:"address,omitempty"`
	Govtid  *GovtidValue `json:"govtid,omitempty"`

	// GovtidExpired `true` if we have a govtid expiration date and it is past that date; `false` if we either can't get an expiration date or it is not expired.
	GovtidExpired *bool         `json:"govtid_Expired,omitempty"`
	Account       *AccountValue `json:"account,omitempty"`
}

// RequestStatus defines model for RequestStatus.
type RequestStatus string

// RequestUpdatedAuditEvent defines model for RequestUpdatedAuditEvent.
type RequestUpdatedAuditEvent struct {
	RequestID string               `json:"request_id"`
	Request   UpdateRequestRequest `json:"request"`
}

// RequestVerificationSource defines model for RequestVerificationSource.
type RequestVerificationSource string

// Role defines model for Role.
type Role string

// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
type Scope string

// SelfieCompareAuditEvent defines model for SelfieCompareAuditEvent.
type SelfieCompareAuditEvent struct {
	Response CompareSelfieResult `json:"response"`
	Subject  string              `json:"subject"`
}

// SharingRevokedAuditEvent defines model for SharingRevokedAuditEvent.
type SharingRevokedAuditEvent struct {
	Claims  []Claim  `json:"claims"`
	Scopes  *[]Scope `json:"scopes,omitempty"`
	Subject string   `json:"subject"`
}

// SlackIntegration defines model for SlackIntegration.
type SlackIntegration struct {
	// ID The unique identifier for the Slack integration
	ID string `json:"id"`

	// Name The name of the Slack workspace associated with this integration.
	Name string `json:"name"`

	// Icon The URL for the icon of the Slack workspace associated with this integration.
	Icon string `json:"icon"`

	// Connected Whether or not this integration is connected to Nametag.  If this is `false`, there may be issues with the auth token that Nametag has that can be solved by reconnecting this workspace.
	Connected bool `json:"connected"`
}

// SlackRequestDetailsResponse defines model for SlackRequestDetailsResponse.
type SlackRequestDetailsResponse struct {
	OrgMember OrgMember `json:"orgMember"`
	Request   Request   `json:"request"`
}

// SubjectComparisonRequest defines model for SubjectComparisonRequest.
type SubjectComparisonRequest struct {
	// Expectations A list of expectations to compare against the person's properties.
	Expectations []Expectation `json:"expectations"`
}

// Template defines model for Template.
type Template struct {
	// ID A unique identifier for the template
	ID string `json:"id"`

	// CreatedAt When the template was created
	CreatedAt time.Time `json:"created_at"`

	// Name A descriptive name of the template
	Name string `json:"name"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline string `json:"headline"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline string `json:"qr_headline"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human-readable form, e.g. "3 hours"
	ExpirationText string `json:"expiration_text"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText string `json:"accept_text"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText string `json:"accepted_text"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS string `json:"install_message_sms"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault bool `json:"is_default"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn int `json:"scopes_expire_in"`

	// ClaimDefinitions A list of claims that are requested when requests are created with this template.
	ClaimDefinitions []TemplateClaimDefinition `json:"claim_definitions"`

	// ClaimsExpireIn How long the data sharing authorization should last, in seconds.
	ClaimsExpireIn int `json:"claims_expire_in"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled bool `json:"enabled"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification bool `json:"require_selfie_reverification"`

	// QRCustomText The text that appears below the desktop QR page headline.
	QRCustomText string `json:"qr_custom_text"`
}

// TemplateClaimDefinition defines model for TemplateClaimDefinition.
type TemplateClaimDefinition struct {
	// Claim Claims are used to describe the information you want people to share with you. In order to request a claim you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Claim Claim `json:"claim"`
}

// TemplateCreatedAuditEvent defines model for TemplateCreatedAuditEvent.
type TemplateCreatedAuditEvent struct {
	Request  CreateTemplateRequest  `json:"request"`
	Response CreateTemplateResponse `json:"response"`
}

// TemplateDeletedAuditEvent defines model for TemplateDeletedAuditEvent.
type TemplateDeletedAuditEvent struct {
	Template string `json:"template"`
}

// TemplateScopeDefinition defines model for TemplateScopeDefinition.
type TemplateScopeDefinition struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the Nametag console.
	Scope Scope `json:"scope"`

	// RestrictEmailDomains If the scope definition is for nt:email or similar, require that the email domain match one of the provided values. If the scope definition is not for email, or if the list is empty, then emails from any domain are allowed.
	RestrictEmailDomains []string `json:"restrict_email_domains,omitempty"`
}

// TemplateUpdatedAuditEvent defines model for TemplateUpdatedAuditEvent.
type TemplateUpdatedAuditEvent struct {
	Request  UpdateTemplateRequest `json:"request"`
	Template string                `json:"template"`
}

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	GrantType    TokenRequestGrantType `json:"grant_type"`
	ClientID     string                `json:"client_id"`
	ClientSecret string                `json:"client_secret"`
	RedirectURI  string                `json:"redirect_uri"`
	Code         string                `json:"code"`
	CodeVerifier *string               `json:"code_verifier,omitempty"`
}

// TokenRequestGrantType defines model for TokenRequest.GrantType.
type TokenRequestGrantType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string                 `json:"access_token"`
	RefreshToken string                 `json:"refresh_token"`
	IDToken      string                 `json:"id_token"`
	Scope        string                 `json:"scope"`
	Claims       string                 `json:"claims"`
	ExpiresIn    int                    `json:"expires_in"`
	TokenType    TokenResponseTokenType `json:"token_type"`
	Subject      string                 `json:"subject"`
}

// TokenResponseTokenType defines model for TokenResponse.TokenType.
type TokenResponseTokenType string

// TokenResponseError defines model for TokenResponseError.
type TokenResponseError struct {
	Code             string `json:"error"`
	ErrorDescription string `json:"error_description,omitempty"`
	URI              string `json:"uri,omitempty"`
}

// UpdateDirectoryRequest defines model for UpdateDirectoryRequest.
type UpdateDirectoryRequest struct {
	AuthenticatePolicy        *RecoveryPolicyRules `json:"authenticate_policy,omitempty"`
	PasswordPolicy            *RecoveryPolicyRules `json:"password_policy,omitempty"`
	MfaPolicy                 *RecoveryPolicyRules `json:"mfa_policy,omitempty"`
	UnlockPolicy              *RecoveryPolicyRules `json:"unlock_policy,omitempty"`
	TemporaryAccessPassPolicy *RecoveryPolicyRules `json:"temporary_access_pass_policy,omitempty"`

	// TemporaryAccessPassLifetimeMinutes The validity period of a temporary access pass in minutes
	TemporaryAccessPassLifetimeMinutes *int `json:"temporary_access_pass_lifetime_minutes,omitempty"`

	// TemporaryAccessPassReusable True if temporary access passes can be used more than once
	TemporaryAccessPassReusable *bool `json:"temporary_access_pass_reusable,omitempty"`

	// BirthDateHMACSecret A shared secret for hashed birth dates in the directory
	BirthDateHMACSecret        []byte                      `json:"birth_date_hmac_secret,omitempty"`
	RecoveryOperationRateLimit *RecoveryOperationRateLimit `json:"recovery_operation_rate_limit,omitempty"`
}

// UpdateOrgMemberRequest defines model for UpdateOrgMemberRequest.
type UpdateOrgMemberRequest struct {
	// Envs The list of environments the member will have access to. If the list contains `*`, the member will have access
	// to all environments.
	Envs []string `json:"envs,omitempty"`
	Role *Role    `json:"role,omitempty"`
}

// UpdateRequestRequest defines model for UpdateRequestRequest.
type UpdateRequestRequest struct {
	// Label An internal label for this request. You can use this field to help you track the request in your own systems. Nametag stores this field, but does not process it.
	Label *string `json:"label,omitempty"`
}

// UpdateTemplateRequest defines model for UpdateTemplateRequest.
type UpdateTemplateRequest struct {
	// Name A descriptive name of the template
	Name *string `json:"name,omitempty"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline *string `json:"headline,omitempty"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline *string `json:"qr_headline,omitempty"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human-readable form, e.g. "3 hours"
	ExpirationText *string `json:"expiration_text,omitempty"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText *string `json:"accept_text,omitempty"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText *string `json:"accepted_text,omitempty"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS *string `json:"install_message_sms,omitempty"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault *bool `json:"is_default,omitempty"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions,omitempty"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn *int `json:"scopes_expire_in,omitempty"`

	// ClaimDefinitions A list of scopes that are requested when requests are created with this template.
	ClaimDefinitions []TemplateClaimDefinition `json:"claim_definitions,omitempty"`

	// ClaimsExpireIn How long the data sharing authorization should last, in seconds.
	ClaimsExpireIn *int `json:"claims_expire_in,omitempty"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification *bool `json:"require_selfie_reverification,omitempty"`

	// QRCustomText The text that appears below the desktop QR page headline.
	QRCustomText *string `json:"qr_custom_text,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	ID            string           `json:"id"`
	Status        int              `json:"status"`
	URL           string           `json:"url"`
	Body          string           `json:"body"`
	RequestHeader []WebhookHeader  `json:"request_header"`
	Attempts      []WebhookAttempt `json:"attempts"`
}

// WebhookAttempt defines model for WebhookAttempt.
type WebhookAttempt struct {
	StartTime time.Time       `json:"start_time"`
	EndTime   time.Time       `json:"end_time"`
	Status    int             `json:"status"`
	Header    []WebhookHeader `json:"header"`
	Body      string          `json:"body"`
	Error     string          `json:"error,omitempty"`
}

// WebhookDefinition defines model for WebhookDefinition.
type WebhookDefinition struct {
	// ID A unique identifier for the webhook definition.
	ID string `json:"id"`

	// URL The URL in your service that should be called, e.g. `https://example.com/__callback`
	URL string `json:"url"`

	// Enabled If true, then calls to this webhook should be made.
	Enabled bool `json:"enabled"`

	// Events The names of the events that should be sent.
	Events []WebhookEventType `json:"events"`

	// AuthorizationHeader The value of the Authorization header to include in the webhook request.
	AuthorizationHeader *string `json:"authorization_header,omitempty"`
}

// WebhookDefinitionUpdate defines model for WebhookDefinitionUpdate.
type WebhookDefinitionUpdate struct {
	ID      string             `json:"id"`
	URL     *string            `json:"url,omitempty"`
	Enabled *bool              `json:"enabled,omitempty"`
	Events  []WebhookEventType `json:"events,omitempty"`

	// AuthorizationHeader The value of the Authorization header to include in the webhook request.
	AuthorizationHeader *string `json:"authorization_header,omitempty"`
}

// WebhookEventType defines model for WebhookEventType.
type WebhookEventType string

// WebhookHeader defines model for WebhookHeader.
type WebhookHeader struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// N400 defines model for 400.
type N400 = BadRequestResponse

// BulkUploadAccountPhotosParams defines parameters for BulkUploadAccountPhotos.
type BulkUploadAccountPhotosParams struct {
	// Directory Modify only accounts in the specified directory(s)
	Directory string `form:"directory" json:"directory"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// Envs List only accounts in the specified environments
	Envs *[]string `form:"env,omitempty" json:"env,omitempty"`

	// Offset The offset to start from
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Count The number of items to return
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Verified Show only verified accounts
	Verified *bool `form:"verified,omitempty" json:"verified,omitempty"`

	// Directories Show only accounts in these directories
	Directories *[]string `form:"directory,omitempty" json:"directory,omitempty"`

	// Q Search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// ListAuditEventsParams defines parameters for ListAuditEvents.
type ListAuditEventsParams struct {
	// Start Show records created at or after this time
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Show records created before this time
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Reverse If false (the default), logs are emitted newest to oldest. If this parameter is true, logs are emitted  oldest to newest.
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Count The number of items to return. Note that the API may return fewer items than specified (even zero) and there  still may be more records available if the forward_cursor or backward_cursor response fields are set.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Env Limit audit events to those relating to the specified environment (or environments)
	Env *[]string `form:"env,omitempty" json:"env,omitempty"`

	// Kind Limit audit events to those matching the specified kind.
	Kind *[]AuditEventKind `form:"kind,omitempty" json:"kind,omitempty"`

	// Query Show only results containing the specified query string.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Cursor Continue a paginated query that previously returned a  cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// Oauth2CancelParams defines parameters for Oauth2Cancel.
type Oauth2CancelParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// Oauth2PollParams defines parameters for Oauth2Poll.
type Oauth2PollParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// UploadDirectoryLogoMultipartBody defines parameters for UploadDirectoryLogo.
type UploadDirectoryLogoMultipartBody struct {
	Logo *openapi_types.File `json:"logo,omitempty"`
}

// DeleteLogoParams defines parameters for DeleteLogo.
type DeleteLogoParams struct {
	// Kind The kind of logo to remove
	Kind LogoKind `form:"kind" json:"kind"`
}

// UploadLogoMultipartBody defines parameters for UploadLogo.
type UploadLogoMultipartBody struct {
	Logo *openapi_types.File `json:"logo,omitempty"`
}

// UploadLogoParams defines parameters for UploadLogo.
type UploadLogoParams struct {
	// Kind The kind of logo to upload
	Kind *LogoKind `form:"kind,omitempty" json:"kind,omitempty"`
}

// GetEnvMicrometricsParams defines parameters for GetEnvMicrometrics.
type GetEnvMicrometricsParams struct {
	Requestor    *string                   `form:"requestor,omitempty" json:"requestor,omitempty"`
	StatusFilter *EnvStatusFilterParams    `form:"statusFilter,omitempty" json:"statusFilter,omitempty"`
	UpdatedAt    *EnvUpdatedAtFilterParams `form:"updatedAt,omitempty" json:"updatedAt,omitempty"`
}

// ListEnvRequestsParams defines parameters for ListEnvRequests.
type ListEnvRequestsParams struct {
	Q            *string                    `form:"q,omitempty" json:"q,omitempty"`
	Requestor    *string                    `form:"requestor,omitempty" json:"requestor,omitempty"`
	Count        *int                       `form:"count,omitempty" json:"count,omitempty"`
	Offset       *int                       `form:"offset,omitempty" json:"offset,omitempty"`
	Sort         *ListEnvRequestsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
	StatusFilter *EnvStatusFilterParams     `form:"statusFilter,omitempty" json:"statusFilter,omitempty"`
	UpdatedAt    *EnvUpdatedAtFilterParams  `form:"updatedAt,omitempty" json:"updatedAt,omitempty"`
}

// ListEnvRequestsParamsSort defines parameters for ListEnvRequests.
type ListEnvRequestsParamsSort string

// Oauth2AuthorizeParams defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeParamsResponseType defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsResponseType string

// Oauth2AuthorizeParamsResponseMode defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsResponseMode string

// Oauth2AuthorizeParamsCodeChallengeMethod defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsCodeChallengeMethod string

// Oauth2AuthorizeIframeParams defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeIframeParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeIframeParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeIframeParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// ThemeColor The QR code color
	ThemeColor *string `form:"theme_color,omitempty" json:"theme_color,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeIframeParamsResponseType defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsResponseType string

// Oauth2AuthorizeIframeParamsResponseMode defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsResponseMode string

// Oauth2AuthorizeIframeParamsCodeChallengeMethod defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsCodeChallengeMethod string

// Oauth2AuthorizeWithRequestParams defines parameters for Oauth2AuthorizeWithRequest.
type Oauth2AuthorizeWithRequestParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// DeletePersonPropertiesParams defines parameters for DeletePersonProperties.
type DeletePersonPropertiesParams struct {
	// Token The `id_token` you received from the `/token` endpoint. This may only be used if the subject is the special value `me`.
	Token  *string `form:"token,omitempty" json:"token,omitempty"`
	Origin *string `json:"Origin,omitempty"`
}

// GetPersonPropertiesParams defines parameters for GetPersonProperties.
type GetPersonPropertiesParams struct {
	// Token The `id_token` you received from the `/token` endpoint. This may only be used if the subject is the special value `me`.
	Token  *string `form:"token,omitempty" json:"token,omitempty"`
	Origin *string `json:"Origin,omitempty"`
}

// Oauth2AuthorizeWithExperienceParams defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeWithExperienceParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeWithExperienceParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeWithExperienceParamsResponseType defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsResponseType string

// Oauth2AuthorizeWithExperienceParamsResponseMode defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsResponseMode string

// Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod string

// Oauth2AuthorizeWithRequestAndExperienceParams defines parameters for Oauth2AuthorizeWithRequestAndExperience.
type Oauth2AuthorizeWithRequestAndExperienceParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// BulkUpdateAccountsJSONRequestBody defines body for BulkUpdateAccounts for application/json ContentType.
type BulkUpdateAccountsJSONRequestBody = AccountBulkUpdateRequest

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody = AccountUpdateRequest

// CreateAPIKeyJSONRequestBody defines body for CreateAPIKey for application/json ContentType.
type CreateAPIKeyJSONRequestBody = CreateAPIKeyRequest

// UpdateAPIKeyJSONRequestBody defines body for UpdateAPIKey for application/json ContentType.
type UpdateAPIKeyJSONRequestBody = APIKeyUpdateRequest

// CreateDirectoryJSONRequestBody defines body for CreateDirectory for application/json ContentType.
type CreateDirectoryJSONRequestBody = CreateDirectoryRequest

// UpdateDirectoryJSONRequestBody defines body for UpdateDirectory for application/json ContentType.
type UpdateDirectoryJSONRequestBody = UpdateDirectoryRequest

// SetDirectoryCredentialsJSONRequestBody defines body for SetDirectoryCredentials for application/json ContentType.
type SetDirectoryCredentialsJSONRequestBody = Credentials

// UploadDirectoryLogoMultipartRequestBody defines body for UploadDirectoryLogo for multipart/form-data ContentType.
type UploadDirectoryLogoMultipartRequestBody UploadDirectoryLogoMultipartBody

// CreateEnvJSONRequestBody defines body for CreateEnv for application/json ContentType.
type CreateEnvJSONRequestBody = CreateEnvRequest

// UpdateEnvJSONRequestBody defines body for UpdateEnv for application/json ContentType.
type UpdateEnvJSONRequestBody = EnvUpdateRequest

// EncryptSecretJSONRequestBody defines body for EncryptSecret for application/json ContentType.
type EncryptSecretJSONRequestBody = EncryptSecretRequest

// UploadLogoMultipartRequestBody defines body for UploadLogo for multipart/form-data ContentType.
type UploadLogoMultipartRequestBody UploadLogoMultipartBody

// PresignRecoveryMicrositeURLJSONRequestBody defines body for PresignRecoveryMicrositeURL for application/json ContentType.
type PresignRecoveryMicrositeURLJSONRequestBody = RecoveryMicrositePresignRequest

// RefreshWebhookSecretJSONRequestBody defines body for RefreshWebhookSecret for application/json ContentType.
type RefreshWebhookSecretJSONRequestBody = RefreshWebhookSecretRequest

// CreateTemplateJSONRequestBody defines body for CreateTemplate for application/json ContentType.
type CreateTemplateJSONRequestBody = CreateTemplateRequest

// UpdateTemplateJSONRequestBody defines body for UpdateTemplate for application/json ContentType.
type UpdateTemplateJSONRequestBody = UpdateTemplateRequest

// UpdateOrgJSONRequestBody defines body for UpdateOrg for application/json ContentType.
type UpdateOrgJSONRequestBody = OrgUpdateRequest

// InviteOrgMemberJSONRequestBody defines body for InviteOrgMember for application/json ContentType.
type InviteOrgMemberJSONRequestBody = InviteOrgMemberRequest

// UpdateOrgMemberJSONRequestBody defines body for UpdateOrgMember for application/json ContentType.
type UpdateOrgMemberJSONRequestBody = UpdateOrgMemberRequest

// CreateRequestJSONRequestBody defines body for CreateRequest for application/json ContentType.
type CreateRequestJSONRequestBody = CreateRequestRequest

// UpdateRequestJSONRequestBody defines body for UpdateRequest for application/json ContentType.
type UpdateRequestJSONRequestBody = UpdateRequestRequest

// GetBulkPeoplePropertiesJSONRequestBody defines body for GetBulkPeopleProperties for application/json ContentType.
type GetBulkPeoplePropertiesJSONRequestBody = BulkRequest

// ComparePeopleJSONRequestBody defines body for ComparePeople for application/json ContentType.
type ComparePeopleJSONRequestBody = SubjectComparisonRequest

// Oauth2TokenFormdataRequestBody defines body for Oauth2Token for application/x-www-form-urlencoded ContentType.
type Oauth2TokenFormdataRequestBody = TokenRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BulkUploadAccountPhotosWithBody request with any body
	BulkUploadAccountPhotosWithBody(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateAccountsWithBody request with any body
	BulkUpdateAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateAccounts(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountWithBody request with any body
	UpdateAccountWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccount(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAccountPhotoWithBody request with any body
	UploadAccountPhotoWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAPIKeys request
	ListAPIKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAPIKeyWithBody request with any body
	CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAPIKey request
	DeleteAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIKey request
	GetAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAPIKeyWithBody request with any body
	UpdateAPIKeyWithBody(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAPIKey(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditEvents request
	ListAuditEvents(ctx context.Context, params *ListAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Cancel request
	Oauth2Cancel(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Poll request
	Oauth2Poll(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectories request
	ListDirectories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectoryWithBody request with any body
	CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectory request
	DeleteDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDirectory request
	GetDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDirectoryWithBody request with any body
	UpdateDirectoryWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDirectory(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDirectoryAuthorizationURL request
	GetDirectoryAuthorizationURL(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDirectoryCredentialsWithBody request with any body
	SetDirectoryCredentialsWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDirectoryCredentials(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectoryLogo request
	DeleteDirectoryLogo(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadDirectoryLogoWithBody request with any body
	UploadDirectoryLogoWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateDirectoryAgentToken request
	RegenerateDirectoryAgentToken(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncDirectory request
	SyncDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvs request
	ListEnvs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvWithBody request with any body
	CreateEnvWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnv(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnv request
	DeleteEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnv request
	GetEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvWithBody request with any body
	UpdateEnvWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnv(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptSecretWithBody request with any body
	EncryptSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EncryptSecret(ctx context.Context, env string, body EncryptSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogo request
	DeleteLogo(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLogoWithBody request with any body
	UploadLogoWithBody(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvMicrometrics request
	GetEnvMicrometrics(ctx context.Context, env string, params *GetEnvMicrometricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PresignRecoveryMicrositeURLWithBody request with any body
	PresignRecoveryMicrositeURLWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PresignRecoveryMicrositeURL(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshWebhookSecretWithBody request with any body
	RefreshWebhookSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshWebhookSecret(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvRequests request
	ListEnvRequests(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvRequest request
	GetEnvRequest(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSlackIntegrations request
	ListSlackIntegrations(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSlackIntegration request
	DeleteSlackIntegration(ctx context.Context, env string, integration string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateWithBody request with any body
	CreateTemplateWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplate(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplate request
	DeleteTemplate(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTemplateWithBody request with any body
	UpdateTemplateWithBody(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTemplate(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhooks request
	ListWebhooks(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSlackRequestDetails request
	GetSlackRequestDetails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrg request
	GetOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrgWithBody request with any body
	UpdateOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrg(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrgMembers request
	ListOrgMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteOrgMemberWithBody request with any body
	InviteOrgMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteOrgMember(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOrgMember request
	RemoveOrgMember(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrgMemberWithBody request with any body
	UpdateOrgMemberWithBody(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrgMember(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequestWithBody request with any body
	CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelRequest request
	CancelRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequest request
	GetRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRequestWithBody request with any body
	UpdateRequestWithBody(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRequest(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Authorize request
	Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeIframe request
	Oauth2AuthorizeIframe(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithRequest request
	Oauth2AuthorizeWithRequest(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Logout request
	Oauth2Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBulkPeoplePropertiesWithBody request with any body
	GetBulkPeoplePropertiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBulkPeopleProperties(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ComparePeopleWithBody request with any body
	ComparePeopleWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ComparePeople(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompareSelfieWithBody request with any body
	CompareSelfieWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonProperties request
	DeletePersonProperties(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonProperties request
	GetPersonProperties(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2TokenWithBody request with any body
	Oauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Oauth2TokenWithFormdataBody(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithExperience request
	Oauth2AuthorizeWithExperience(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithRequestAndExperience request
	Oauth2AuthorizeWithRequestAndExperience(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BulkUploadAccountPhotosWithBody(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadAccountPhotosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAccounts(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, account)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithBody(c.Server, account, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccount(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequest(c.Server, account, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAccountPhotoWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAccountPhotoRequestWithBody(c.Server, account, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAPIKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIKeyRequest(c.Server, apiKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIKeyRequest(c.Server, apiKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKeyWithBody(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequestWithBody(c.Server, apiKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKey(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequest(c.Server, apiKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditEvents(ctx context.Context, params *ListAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Cancel(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2CancelRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Poll(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2PollRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectoryWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectoryRequestWithBody(c.Server, directory, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectory(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectoryRequest(c.Server, directory, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDirectoryAuthorizationURL(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDirectoryAuthorizationURLRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDirectoryCredentialsWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDirectoryCredentialsRequestWithBody(c.Server, directory, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDirectoryCredentials(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDirectoryCredentialsRequest(c.Server, directory, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectoryLogo(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectoryLogoRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadDirectoryLogoWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadDirectoryLogoRequestWithBody(c.Server, directory, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateDirectoryAgentToken(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateDirectoryAgentTokenRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnv(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnv(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptSecretRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptSecret(ctx context.Context, env string, body EncryptSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptSecretRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogo(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogoRequest(c.Server, env, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLogoWithBody(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLogoRequestWithBody(c.Server, env, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvMicrometrics(ctx context.Context, env string, params *GetEnvMicrometricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvMicrometricsRequest(c.Server, env, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PresignRecoveryMicrositeURLWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPresignRecoveryMicrositeURLRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PresignRecoveryMicrositeURL(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPresignRecoveryMicrositeURLRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshWebhookSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshWebhookSecretRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshWebhookSecret(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshWebhookSecretRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvRequests(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvRequestsRequest(c.Server, env, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvRequest(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvRequestRequest(c.Server, env, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSlackIntegrations(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSlackIntegrationsRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSlackIntegration(ctx context.Context, env string, integration string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSlackIntegrationRequest(c.Server, env, integration)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplate(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplate(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplateRequest(c.Server, env, template)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplateWithBody(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequestWithBody(c.Server, env, template, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplate(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequest(c.Server, env, template, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhooks(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhooksRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSlackRequestDetails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSlackRequestDetailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrg(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrgMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrgMembersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteOrgMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteOrgMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteOrgMember(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteOrgMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOrgMember(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOrgMemberRequest(c.Server, member)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgMemberWithBody(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgMemberRequestWithBody(c.Server, member, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgMember(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgMemberRequest(c.Server, member, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelRequestRequest(c.Server, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestRequest(c.Server, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequestWithBody(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequestWithBody(c.Server, requestID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequest(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequest(c.Server, requestID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeIframe(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeIframeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithRequest(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithRequestRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2LogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkPeoplePropertiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkPeoplePropertiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkPeopleProperties(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkPeoplePropertiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComparePeopleWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComparePeopleRequestWithBody(c.Server, subject, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComparePeople(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComparePeopleRequest(c.Server, subject, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompareSelfieWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompareSelfieRequestWithBody(c.Server, subject, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonProperties(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonPropertiesRequest(c.Server, subject, scopes, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonProperties(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonPropertiesRequest(c.Server, subject, scopes, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenWithFormdataBody(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithExperience(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithExperienceRequest(c.Server, experience, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithRequestAndExperience(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithRequestAndExperienceRequest(c.Server, experience, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBulkUploadAccountPhotosRequestWithBody generates requests for BulkUploadAccountPhotos with any type of body
func NewBulkUploadAccountPhotosRequestWithBody(server string, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/account/photos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directory", runtime.ParamLocationQuery, params.Directory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Envs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env", runtime.ParamLocationQuery, *params.Envs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Verified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, *params.Verified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Directories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directory", runtime.ParamLocationQuery, *params.Directories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateAccountsRequest calls the generic BulkUpdateAccounts builder with application/json body
func NewBulkUpdateAccountsRequest(server string, body BulkUpdateAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateAccountsRequestWithBody generates requests for BulkUpdateAccounts with any type of body
func NewBulkUpdateAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, account string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountRequest calls the generic UpdateAccount builder with application/json body
func NewUpdateAccountRequest(server string, account string, body UpdateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountRequestWithBody(server, account, "application/json", bodyReader)
}

// NewUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func NewUpdateAccountRequestWithBody(server string, account string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadAccountPhotoRequestWithBody generates requests for UploadAccountPhoto with any type of body
func NewUploadAccountPhotoRequestWithBody(server string, account string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s/photo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAPIKeysRequest generates requests for ListAPIKeys
func NewListAPIKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAPIKeyRequest calls the generic CreateAPIKey builder with application/json body
func NewCreateAPIKeyRequest(server string, body CreateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAPIKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAPIKeyRequestWithBody generates requests for CreateAPIKey with any type of body
func NewCreateAPIKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAPIKeyRequest generates requests for DeleteAPIKey
func NewDeleteAPIKeyRequest(server string, apiKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIKeyRequest generates requests for GetAPIKey
func NewGetAPIKeyRequest(server string, apiKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAPIKeyRequest calls the generic UpdateAPIKey builder with application/json body
func NewUpdateAPIKeyRequest(server string, apiKey string, body UpdateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAPIKeyRequestWithBody(server, apiKey, "application/json", bodyReader)
}

// NewUpdateAPIKeyRequestWithBody generates requests for UpdateAPIKey with any type of body
func NewUpdateAPIKeyRequestWithBody(server string, apiKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAuditEventsRequest generates requests for ListAuditEvents
func NewListAuditEventsRequest(server string, params *ListAuditEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/audit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Env != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env", runtime.ParamLocationQuery, *params.Env); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2CancelRequest generates requests for Oauth2Cancel
func NewOauth2CancelRequest(server string, requestID string, params *Oauth2CancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/authorize/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewOauth2PollRequest generates requests for Oauth2Poll
func NewOauth2PollRequest(server string, requestID string, params *Oauth2PollParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/authorize/%s/poll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewListDirectoriesRequest generates requests for ListDirectories
func NewListDirectoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectoryRequest calls the generic CreateDirectory builder with application/json body
func NewCreateDirectoryRequest(server string, body CreateDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectoryRequestWithBody generates requests for CreateDirectory with any type of body
func NewCreateDirectoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectoryRequest generates requests for DeleteDirectory
func NewDeleteDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDirectoryRequest generates requests for GetDirectory
func NewGetDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDirectoryRequest calls the generic UpdateDirectory builder with application/json body
func NewUpdateDirectoryRequest(server string, directory string, body UpdateDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDirectoryRequestWithBody(server, directory, "application/json", bodyReader)
}

// NewUpdateDirectoryRequestWithBody generates requests for UpdateDirectory with any type of body
func NewUpdateDirectoryRequestWithBody(server string, directory string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDirectoryAuthorizationURLRequest generates requests for GetDirectoryAuthorizationURL
func NewGetDirectoryAuthorizationURLRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDirectoryCredentialsRequest calls the generic SetDirectoryCredentials builder with application/json body
func NewSetDirectoryCredentialsRequest(server string, directory string, body SetDirectoryCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDirectoryCredentialsRequestWithBody(server, directory, "application/json", bodyReader)
}

// NewSetDirectoryCredentialsRequestWithBody generates requests for SetDirectoryCredentials with any type of body
func NewSetDirectoryCredentialsRequestWithBody(server string, directory string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectoryLogoRequest generates requests for DeleteDirectoryLogo
func NewDeleteDirectoryLogoRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadDirectoryLogoRequestWithBody generates requests for UploadDirectoryLogo with any type of body
func NewUploadDirectoryLogoRequestWithBody(server string, directory string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegenerateDirectoryAgentTokenRequest generates requests for RegenerateDirectoryAgentToken
func NewRegenerateDirectoryAgentTokenRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/regenerate-directory-agent-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncDirectoryRequest generates requests for SyncDirectory
func NewSyncDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/sync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnvsRequest generates requests for ListEnvs
func NewListEnvsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvRequest calls the generic CreateEnv builder with application/json body
func NewCreateEnvRequest(server string, body CreateEnvJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEnvRequestWithBody generates requests for CreateEnv with any type of body
func NewCreateEnvRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvRequest generates requests for DeleteEnv
func NewDeleteEnvRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvRequest generates requests for GetEnv
func NewGetEnvRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvRequest calls the generic UpdateEnv builder with application/json body
func NewUpdateEnvRequest(server string, env string, body UpdateEnvJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvRequestWithBody(server, env, "application/json", bodyReader)
}

// NewUpdateEnvRequestWithBody generates requests for UpdateEnv with any type of body
func NewUpdateEnvRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEncryptSecretRequest calls the generic EncryptSecret builder with application/json body
func NewEncryptSecretRequest(server string, env string, body EncryptSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEncryptSecretRequestWithBody(server, env, "application/json", bodyReader)
}

// NewEncryptSecretRequestWithBody generates requests for EncryptSecret with any type of body
func NewEncryptSecretRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/encrypt-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogoRequest generates requests for DeleteLogo
func NewDeleteLogoRequest(server string, env string, params *DeleteLogoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLogoRequestWithBody generates requests for UploadLogo with any type of body
func NewUploadLogoRequestWithBody(server string, env string, params *UploadLogoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvMicrometricsRequest generates requests for GetEnvMicrometrics
func NewGetEnvMicrometricsRequest(server string, env string, params *GetEnvMicrometricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/micrometrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Requestor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestor", runtime.ParamLocationQuery, *params.Requestor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusFilter", runtime.ParamLocationQuery, *params.StatusFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAt", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPresignRecoveryMicrositeURLRequest calls the generic PresignRecoveryMicrositeURL builder with application/json body
func NewPresignRecoveryMicrositeURLRequest(server string, env string, body PresignRecoveryMicrositeURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPresignRecoveryMicrositeURLRequestWithBody(server, env, "application/json", bodyReader)
}

// NewPresignRecoveryMicrositeURLRequestWithBody generates requests for PresignRecoveryMicrositeURL with any type of body
func NewPresignRecoveryMicrositeURLRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/recovery_microsite/presign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshWebhookSecretRequest calls the generic RefreshWebhookSecret builder with application/json body
func NewRefreshWebhookSecretRequest(server string, env string, body RefreshWebhookSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshWebhookSecretRequestWithBody(server, env, "application/json", bodyReader)
}

// NewRefreshWebhookSecretRequestWithBody generates requests for RefreshWebhookSecret with any type of body
func NewRefreshWebhookSecretRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/refresh-webhook-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEnvRequestsRequest generates requests for ListEnvRequests
func NewListEnvRequestsRequest(server string, env string, params *ListEnvRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Requestor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestor", runtime.ParamLocationQuery, *params.Requestor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusFilter", runtime.ParamLocationQuery, *params.StatusFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAt", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvRequestRequest generates requests for GetEnvRequest
func NewGetEnvRequestRequest(server string, env string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSlackIntegrationsRequest generates requests for ListSlackIntegrations
func NewListSlackIntegrationsRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSlackIntegrationRequest generates requests for DeleteSlackIntegration
func NewDeleteSlackIntegrationRequest(server string, env string, integration string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "integration", runtime.ParamLocationPath, integration)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/slack/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTemplateRequest calls the generic CreateTemplate builder with application/json body
func NewCreateTemplateRequest(server string, env string, body CreateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateRequestWithBody(server, env, "application/json", bodyReader)
}

// NewCreateTemplateRequestWithBody generates requests for CreateTemplate with any type of body
func NewCreateTemplateRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTemplateRequest generates requests for DeleteTemplate
func NewDeleteTemplateRequest(server string, env string, template string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template", runtime.ParamLocationPath, template)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTemplateRequest calls the generic UpdateTemplate builder with application/json body
func NewUpdateTemplateRequest(server string, env string, template string, body UpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTemplateRequestWithBody(server, env, template, "application/json", bodyReader)
}

// NewUpdateTemplateRequestWithBody generates requests for UpdateTemplate with any type of body
func NewUpdateTemplateRequestWithBody(server string, env string, template string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template", runtime.ParamLocationPath, template)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebhooksRequest generates requests for ListWebhooks
func NewListWebhooksRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSlackRequestDetailsRequest generates requests for GetSlackRequestDetails
func NewGetSlackRequestDetailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/integrations/slack/details")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrgRequest generates requests for GetOrg
func NewGetOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrgRequest calls the generic UpdateOrg builder with application/json body
func NewUpdateOrgRequest(server string, body UpdateOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrgRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateOrgRequestWithBody generates requests for UpdateOrg with any type of body
func NewUpdateOrgRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrgMembersRequest generates requests for ListOrgMembers
func NewListOrgMembersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteOrgMemberRequest calls the generic InviteOrgMember builder with application/json body
func NewInviteOrgMemberRequest(server string, body InviteOrgMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteOrgMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteOrgMemberRequestWithBody generates requests for InviteOrgMember with any type of body
func NewInviteOrgMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveOrgMemberRequest generates requests for RemoveOrgMember
func NewRemoveOrgMemberRequest(server string, member string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrgMemberRequest calls the generic UpdateOrgMember builder with application/json body
func NewUpdateOrgMemberRequest(server string, member string, body UpdateOrgMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrgMemberRequestWithBody(server, member, "application/json", bodyReader)
}

// NewUpdateOrgMemberRequestWithBody generates requests for UpdateOrgMember with any type of body
func NewUpdateOrgMemberRequestWithBody(server string, member string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRequestRequest calls the generic CreateRequest builder with application/json body
func NewCreateRequestRequest(server string, body CreateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestRequestWithBody generates requests for CreateRequest with any type of body
func NewCreateRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelRequestRequest generates requests for CancelRequest
func NewCancelRequestRequest(server string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestRequest generates requests for GetRequest
func NewGetRequestRequest(server string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequestRequest calls the generic UpdateRequest builder with application/json body
func NewUpdateRequestRequest(server string, requestID string, body UpdateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestRequestWithBody(server, requestID, "application/json", bodyReader)
}

// NewUpdateRequestRequestWithBody generates requests for UpdateRequest with any type of body
func NewUpdateRequestRequestWithBody(server string, requestID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauth2AuthorizeRequest generates requests for Oauth2Authorize
func NewOauth2AuthorizeRequest(server string, params *Oauth2AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeIframeRequest generates requests for Oauth2AuthorizeIframe
func NewOauth2AuthorizeIframeRequest(server string, params *Oauth2AuthorizeIframeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/iframe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThemeColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "theme_color", runtime.ParamLocationQuery, *params.ThemeColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeWithRequestRequest generates requests for Oauth2AuthorizeWithRequest
func NewOauth2AuthorizeWithRequestRequest(server string, requestID string, params *Oauth2AuthorizeWithRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewOauth2LogoutRequest generates requests for Oauth2Logout
func NewOauth2LogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBulkPeoplePropertiesRequest calls the generic GetBulkPeopleProperties builder with application/json body
func NewGetBulkPeoplePropertiesRequest(server string, body GetBulkPeoplePropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBulkPeoplePropertiesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetBulkPeoplePropertiesRequestWithBody generates requests for GetBulkPeopleProperties with any type of body
func NewGetBulkPeoplePropertiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewComparePeopleRequest calls the generic ComparePeople builder with application/json body
func NewComparePeopleRequest(server string, subject string, body ComparePeopleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewComparePeopleRequestWithBody(server, subject, "application/json", bodyReader)
}

// NewComparePeopleRequestWithBody generates requests for ComparePeople with any type of body
func NewComparePeopleRequestWithBody(server string, subject string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/compare", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompareSelfieRequestWithBody generates requests for CompareSelfie with any type of body
func NewCompareSelfieRequestWithBody(server string, subject string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/compare/selfie", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersonPropertiesRequest generates requests for DeletePersonProperties
func NewDeletePersonPropertiesRequest(server string, subject string, scopes string, params *DeletePersonPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopes", runtime.ParamLocationPath, scopes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Origin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Origin", headerParam0)
		}

	}

	return req, nil
}

// NewGetPersonPropertiesRequest generates requests for GetPersonProperties
func NewGetPersonPropertiesRequest(server string, subject string, scopes string, params *GetPersonPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopes", runtime.ParamLocationPath, scopes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Origin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Origin", headerParam0)
		}

	}

	return req, nil
}

// NewOauth2TokenRequestWithFormdataBody calls the generic Oauth2Token builder with application/x-www-form-urlencoded body
func NewOauth2TokenRequestWithFormdataBody(server string, body Oauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewOauth2TokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewOauth2TokenRequestWithBody generates requests for Oauth2Token with any type of body
func NewOauth2TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauth2AuthorizeWithExperienceRequest generates requests for Oauth2AuthorizeWithExperience
func NewOauth2AuthorizeWithExperienceRequest(server string, experience string, params *Oauth2AuthorizeWithExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experience", runtime.ParamLocationPath, experience)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/x/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeWithRequestAndExperienceRequest generates requests for Oauth2AuthorizeWithRequestAndExperience
func NewOauth2AuthorizeWithRequestAndExperienceRequest(server string, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experience", runtime.ParamLocationPath, experience)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/x/%s/authorize/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BulkUploadAccountPhotosWithBodyWithResponse request with any body
	BulkUploadAccountPhotosWithBodyWithResponse(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadAccountPhotosResp, error)

	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResp, error)

	// BulkUpdateAccountsWithBodyWithResponse request with any body
	BulkUpdateAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error)

	BulkUpdateAccountsWithResponse(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*GetAccountResp, error)

	// UpdateAccountWithBodyWithResponse request with any body
	UpdateAccountWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error)

	UpdateAccountWithResponse(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error)

	// UploadAccountPhotoWithBodyWithResponse request with any body
	UploadAccountPhotoWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAccountPhotoResp, error)

	// ListAPIKeysWithResponse request
	ListAPIKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIKeysResp, error)

	// CreateAPIKeyWithBodyWithResponse request with any body
	CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error)

	CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error)

	// DeleteAPIKeyWithResponse request
	DeleteAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResp, error)

	// GetAPIKeyWithResponse request
	GetAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*GetAPIKeyResp, error)

	// UpdateAPIKeyWithBodyWithResponse request with any body
	UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error)

	UpdateAPIKeyWithResponse(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error)

	// ListAuditEventsWithResponse request
	ListAuditEventsWithResponse(ctx context.Context, params *ListAuditEventsParams, reqEditors ...RequestEditorFn) (*ListAuditEventsResp, error)

	// Oauth2CancelWithResponse request
	Oauth2CancelWithResponse(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*Oauth2CancelResp, error)

	// Oauth2PollWithResponse request
	Oauth2PollWithResponse(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*Oauth2PollResp, error)

	// ListDirectoriesWithResponse request
	ListDirectoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDirectoriesResp, error)

	// CreateDirectoryWithBodyWithResponse request with any body
	CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error)

	CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error)

	// DeleteDirectoryWithResponse request
	DeleteDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryResp, error)

	// GetDirectoryWithResponse request
	GetDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryResp, error)

	// UpdateDirectoryWithBodyWithResponse request with any body
	UpdateDirectoryWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error)

	UpdateDirectoryWithResponse(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error)

	// GetDirectoryAuthorizationURLWithResponse request
	GetDirectoryAuthorizationURLWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryAuthorizationURLResp, error)

	// SetDirectoryCredentialsWithBodyWithResponse request with any body
	SetDirectoryCredentialsWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error)

	SetDirectoryCredentialsWithResponse(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error)

	// DeleteDirectoryLogoWithResponse request
	DeleteDirectoryLogoWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryLogoResp, error)

	// UploadDirectoryLogoWithBodyWithResponse request with any body
	UploadDirectoryLogoWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDirectoryLogoResp, error)

	// RegenerateDirectoryAgentTokenWithResponse request
	RegenerateDirectoryAgentTokenWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*RegenerateDirectoryAgentTokenResp, error)

	// SyncDirectoryWithResponse request
	SyncDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*SyncDirectoryResp, error)

	// ListEnvsWithResponse request
	ListEnvsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEnvsResp, error)

	// CreateEnvWithBodyWithResponse request with any body
	CreateEnvWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvResp, error)

	CreateEnvWithResponse(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvResp, error)

	// DeleteEnvWithResponse request
	DeleteEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*DeleteEnvResp, error)

	// GetEnvWithResponse request
	GetEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*GetEnvResp, error)

	// UpdateEnvWithBodyWithResponse request with any body
	UpdateEnvWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error)

	UpdateEnvWithResponse(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error)

	// EncryptSecretWithBodyWithResponse request with any body
	EncryptSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptSecretResp, error)

	EncryptSecretWithResponse(ctx context.Context, env string, body EncryptSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptSecretResp, error)

	// DeleteLogoWithResponse request
	DeleteLogoWithResponse(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*DeleteLogoResp, error)

	// UploadLogoWithBodyWithResponse request with any body
	UploadLogoWithBodyWithResponse(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogoResp, error)

	// GetEnvMicrometricsWithResponse request
	GetEnvMicrometricsWithResponse(ctx context.Context, env string, params *GetEnvMicrometricsParams, reqEditors ...RequestEditorFn) (*GetEnvMicrometricsResp, error)

	// PresignRecoveryMicrositeURLWithBodyWithResponse request with any body
	PresignRecoveryMicrositeURLWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error)

	PresignRecoveryMicrositeURLWithResponse(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error)

	// RefreshWebhookSecretWithBodyWithResponse request with any body
	RefreshWebhookSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error)

	RefreshWebhookSecretWithResponse(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error)

	// ListEnvRequestsWithResponse request
	ListEnvRequestsWithResponse(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*ListEnvRequestsResp, error)

	// GetEnvRequestWithResponse request
	GetEnvRequestWithResponse(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*GetEnvRequestResp, error)

	// ListSlackIntegrationsWithResponse request
	ListSlackIntegrationsWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListSlackIntegrationsResp, error)

	// DeleteSlackIntegrationWithResponse request
	DeleteSlackIntegrationWithResponse(ctx context.Context, env string, integration string, reqEditors ...RequestEditorFn) (*DeleteSlackIntegrationResp, error)

	// CreateTemplateWithBodyWithResponse request with any body
	CreateTemplateWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error)

	CreateTemplateWithResponse(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error)

	// DeleteTemplateWithResponse request
	DeleteTemplateWithResponse(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*DeleteTemplateResp, error)

	// UpdateTemplateWithBodyWithResponse request with any body
	UpdateTemplateWithBodyWithResponse(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	UpdateTemplateWithResponse(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	// ListWebhooksWithResponse request
	ListWebhooksWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListWebhooksResp, error)

	// GetSlackRequestDetailsWithResponse request
	GetSlackRequestDetailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSlackRequestDetailsResp, error)

	// GetOrgWithResponse request
	GetOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrgResp, error)

	// UpdateOrgWithBodyWithResponse request with any body
	UpdateOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error)

	UpdateOrgWithResponse(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error)

	// ListOrgMembersWithResponse request
	ListOrgMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrgMembersResp, error)

	// InviteOrgMemberWithBodyWithResponse request with any body
	InviteOrgMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error)

	InviteOrgMemberWithResponse(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error)

	// RemoveOrgMemberWithResponse request
	RemoveOrgMemberWithResponse(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*RemoveOrgMemberResp, error)

	// UpdateOrgMemberWithBodyWithResponse request with any body
	UpdateOrgMemberWithBodyWithResponse(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error)

	UpdateOrgMemberWithResponse(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error)

	// CreateRequestWithBodyWithResponse request with any body
	CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResp, error)

	CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResp, error)

	// CancelRequestWithResponse request
	CancelRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*CancelRequestResp, error)

	// GetRequestWithResponse request
	GetRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*GetRequestResp, error)

	// UpdateRequestWithBodyWithResponse request with any body
	UpdateRequestWithBodyWithResponse(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error)

	UpdateRequestWithResponse(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error)

	// Oauth2AuthorizeWithResponse request
	Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResp, error)

	// Oauth2AuthorizeIframeWithResponse request
	Oauth2AuthorizeIframeWithResponse(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeIframeResp, error)

	// Oauth2AuthorizeWithRequestWithResponse request
	Oauth2AuthorizeWithRequestWithResponse(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestResp, error)

	// Oauth2LogoutWithResponse request
	Oauth2LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Oauth2LogoutResp, error)

	// GetBulkPeoplePropertiesWithBodyWithResponse request with any body
	GetBulkPeoplePropertiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error)

	GetBulkPeoplePropertiesWithResponse(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error)

	// ComparePeopleWithBodyWithResponse request with any body
	ComparePeopleWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error)

	ComparePeopleWithResponse(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error)

	// CompareSelfieWithBodyWithResponse request with any body
	CompareSelfieWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompareSelfieResp, error)

	// DeletePersonPropertiesWithResponse request
	DeletePersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*DeletePersonPropertiesResp, error)

	// GetPersonPropertiesWithResponse request
	GetPersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersonPropertiesResp, error)

	// Oauth2TokenWithBodyWithResponse request with any body
	Oauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error)

	Oauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error)

	// Oauth2AuthorizeWithExperienceWithResponse request
	Oauth2AuthorizeWithExperienceWithResponse(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithExperienceResp, error)

	// Oauth2AuthorizeWithRequestAndExperienceWithResponse request
	Oauth2AuthorizeWithRequestAndExperienceWithResponse(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestAndExperienceResp, error)
}

type BulkUploadAccountPhotosResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkUploadAccountPhotosResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r BulkUploadAccountPhotosResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadAccountPhotosResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsList
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountBulkUpdateResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r BulkUpdateAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAccountPhotoResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadAccountPhotoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAccountPhotoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAPIKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPIKeysResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListAPIKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAPIKeyResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKey
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAuditEventsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListAuditEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2CancelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2CancelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2CancelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2PollResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PollResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2PollResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2PollResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectoriesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDirectoriesResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListDirectoriesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectoriesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateDirectoryResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Directory
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Directory
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDirectoryAuthorizationURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuth2AuthorizeResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetDirectoryAuthorizationURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDirectoryAuthorizationURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDirectoryCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r SetDirectoryCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDirectoryCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectoryLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteDirectoryLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectoryLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadDirectoryLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UploadDirectoryLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadDirectoryLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateDirectoryAgentTokenResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegenerateDirectoryAgentTokenResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r RegenerateDirectoryAgentTokenResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateDirectoryAgentTokenResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r SyncDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEnvsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListEnvsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateEnvResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Env
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptSecretResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptSecretResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r EncryptSecretResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptSecretResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UploadLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvMicrometricsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMicrometricsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetEnvMicrometricsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvMicrometricsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PresignRecoveryMicrositeURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryMicrositePresignResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r PresignRecoveryMicrositeURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PresignRecoveryMicrositeURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshWebhookSecretResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshWebhookSecretResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r RefreshWebhookSecretResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshWebhookSecretResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvRequestsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRequestsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListEnvRequestsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvRequestsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetEnvRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSlackIntegrationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSlackIntegrationsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListSlackIntegrationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSlackIntegrationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSlackIntegrationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteSlackIntegrationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSlackIntegrationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTemplateResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhooksResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhooksResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListWebhooksResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhooksResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSlackRequestDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SlackRequestDetailsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetSlackRequestDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSlackRequestDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Org
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetOrgResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrgResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateOrgResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrgResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrgMembersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOrgMembersResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListOrgMembersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrgMembersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r InviteOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r RemoveOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateRequestResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CancelRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizeResponse
	JSON400      *AuthorizeResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeIframeResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeIframeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeIframeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2LogoutResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2LogoutResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2LogoutResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBulkPeoplePropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetBulkPeoplePropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBulkPeoplePropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ComparePeopleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComparisonResult
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ComparePeopleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ComparePeopleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompareSelfieResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompareSelfieResult
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CompareSelfieResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompareSelfieResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonPropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeletePersonPropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonPropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonPropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PropertiesResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetPersonPropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonPropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2TokenResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *TokenResponseError
}

// Status returns HTTPResponse.Status
func (r Oauth2TokenResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2TokenResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithExperienceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizeResponse
	JSON400      *AuthorizeResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithExperienceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithExperienceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithRequestAndExperienceResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithRequestAndExperienceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithRequestAndExperienceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BulkUploadAccountPhotosWithBodyWithResponse request with arbitrary body returning *BulkUploadAccountPhotosResp
func (c *ClientWithResponses) BulkUploadAccountPhotosWithBodyWithResponse(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadAccountPhotosResp, error) {
	rsp, err := c.BulkUploadAccountPhotosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadAccountPhotosResp(rsp)
}

// ListAccountsWithResponse request returning *ListAccountsResp
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResp, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResp(rsp)
}

// BulkUpdateAccountsWithBodyWithResponse request with arbitrary body returning *BulkUpdateAccountsResp
func (c *ClientWithResponses) BulkUpdateAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error) {
	rsp, err := c.BulkUpdateAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAccountsResp(rsp)
}

func (c *ClientWithResponses) BulkUpdateAccountsWithResponse(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error) {
	rsp, err := c.BulkUpdateAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAccountsResp(rsp)
}

// GetAccountWithResponse request returning *GetAccountResp
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*GetAccountResp, error) {
	rsp, err := c.GetAccount(ctx, account, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResp(rsp)
}

// UpdateAccountWithBodyWithResponse request with arbitrary body returning *UpdateAccountResp
func (c *ClientWithResponses) UpdateAccountWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error) {
	rsp, err := c.UpdateAccountWithBody(ctx, account, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResp(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithResponse(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error) {
	rsp, err := c.UpdateAccount(ctx, account, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResp(rsp)
}

// UploadAccountPhotoWithBodyWithResponse request with arbitrary body returning *UploadAccountPhotoResp
func (c *ClientWithResponses) UploadAccountPhotoWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAccountPhotoResp, error) {
	rsp, err := c.UploadAccountPhotoWithBody(ctx, account, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAccountPhotoResp(rsp)
}

// ListAPIKeysWithResponse request returning *ListAPIKeysResp
func (c *ClientWithResponses) ListAPIKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIKeysResp, error) {
	rsp, err := c.ListAPIKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIKeysResp(rsp)
}

// CreateAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateAPIKeyResp
func (c *ClientWithResponses) CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error) {
	rsp, err := c.CreateAPIKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResp(rsp)
}

func (c *ClientWithResponses) CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error) {
	rsp, err := c.CreateAPIKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResp(rsp)
}

// DeleteAPIKeyWithResponse request returning *DeleteAPIKeyResp
func (c *ClientWithResponses) DeleteAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResp, error) {
	rsp, err := c.DeleteAPIKey(ctx, apiKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIKeyResp(rsp)
}

// GetAPIKeyWithResponse request returning *GetAPIKeyResp
func (c *ClientWithResponses) GetAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*GetAPIKeyResp, error) {
	rsp, err := c.GetAPIKey(ctx, apiKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIKeyResp(rsp)
}

// UpdateAPIKeyWithBodyWithResponse request with arbitrary body returning *UpdateAPIKeyResp
func (c *ClientWithResponses) UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error) {
	rsp, err := c.UpdateAPIKeyWithBody(ctx, apiKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResp(rsp)
}

func (c *ClientWithResponses) UpdateAPIKeyWithResponse(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error) {
	rsp, err := c.UpdateAPIKey(ctx, apiKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResp(rsp)
}

// ListAuditEventsWithResponse request returning *ListAuditEventsResp
func (c *ClientWithResponses) ListAuditEventsWithResponse(ctx context.Context, params *ListAuditEventsParams, reqEditors ...RequestEditorFn) (*ListAuditEventsResp, error) {
	rsp, err := c.ListAuditEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditEventsResp(rsp)
}

// Oauth2CancelWithResponse request returning *Oauth2CancelResp
func (c *ClientWithResponses) Oauth2CancelWithResponse(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*Oauth2CancelResp, error) {
	rsp, err := c.Oauth2Cancel(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2CancelResp(rsp)
}

// Oauth2PollWithResponse request returning *Oauth2PollResp
func (c *ClientWithResponses) Oauth2PollWithResponse(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*Oauth2PollResp, error) {
	rsp, err := c.Oauth2Poll(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2PollResp(rsp)
}

// ListDirectoriesWithResponse request returning *ListDirectoriesResp
func (c *ClientWithResponses) ListDirectoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDirectoriesResp, error) {
	rsp, err := c.ListDirectories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectoriesResp(rsp)
}

// CreateDirectoryWithBodyWithResponse request with arbitrary body returning *CreateDirectoryResp
func (c *ClientWithResponses) CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error) {
	rsp, err := c.CreateDirectoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResp(rsp)
}

func (c *ClientWithResponses) CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error) {
	rsp, err := c.CreateDirectory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResp(rsp)
}

// DeleteDirectoryWithResponse request returning *DeleteDirectoryResp
func (c *ClientWithResponses) DeleteDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryResp, error) {
	rsp, err := c.DeleteDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectoryResp(rsp)
}

// GetDirectoryWithResponse request returning *GetDirectoryResp
func (c *ClientWithResponses) GetDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryResp, error) {
	rsp, err := c.GetDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDirectoryResp(rsp)
}

// UpdateDirectoryWithBodyWithResponse request with arbitrary body returning *UpdateDirectoryResp
func (c *ClientWithResponses) UpdateDirectoryWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error) {
	rsp, err := c.UpdateDirectoryWithBody(ctx, directory, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectoryResp(rsp)
}

func (c *ClientWithResponses) UpdateDirectoryWithResponse(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error) {
	rsp, err := c.UpdateDirectory(ctx, directory, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectoryResp(rsp)
}

// GetDirectoryAuthorizationURLWithResponse request returning *GetDirectoryAuthorizationURLResp
func (c *ClientWithResponses) GetDirectoryAuthorizationURLWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryAuthorizationURLResp, error) {
	rsp, err := c.GetDirectoryAuthorizationURL(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDirectoryAuthorizationURLResp(rsp)
}

// SetDirectoryCredentialsWithBodyWithResponse request with arbitrary body returning *SetDirectoryCredentialsResp
func (c *ClientWithResponses) SetDirectoryCredentialsWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error) {
	rsp, err := c.SetDirectoryCredentialsWithBody(ctx, directory, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDirectoryCredentialsResp(rsp)
}

func (c *ClientWithResponses) SetDirectoryCredentialsWithResponse(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error) {
	rsp, err := c.SetDirectoryCredentials(ctx, directory, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDirectoryCredentialsResp(rsp)
}

// DeleteDirectoryLogoWithResponse request returning *DeleteDirectoryLogoResp
func (c *ClientWithResponses) DeleteDirectoryLogoWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryLogoResp, error) {
	rsp, err := c.DeleteDirectoryLogo(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectoryLogoResp(rsp)
}

// UploadDirectoryLogoWithBodyWithResponse request with arbitrary body returning *UploadDirectoryLogoResp
func (c *ClientWithResponses) UploadDirectoryLogoWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDirectoryLogoResp, error) {
	rsp, err := c.UploadDirectoryLogoWithBody(ctx, directory, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadDirectoryLogoResp(rsp)
}

// RegenerateDirectoryAgentTokenWithResponse request returning *RegenerateDirectoryAgentTokenResp
func (c *ClientWithResponses) RegenerateDirectoryAgentTokenWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*RegenerateDirectoryAgentTokenResp, error) {
	rsp, err := c.RegenerateDirectoryAgentToken(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateDirectoryAgentTokenResp(rsp)
}

// SyncDirectoryWithResponse request returning *SyncDirectoryResp
func (c *ClientWithResponses) SyncDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*SyncDirectoryResp, error) {
	rsp, err := c.SyncDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncDirectoryResp(rsp)
}

// ListEnvsWithResponse request returning *ListEnvsResp
func (c *ClientWithResponses) ListEnvsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEnvsResp, error) {
	rsp, err := c.ListEnvs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvsResp(rsp)
}

// CreateEnvWithBodyWithResponse request with arbitrary body returning *CreateEnvResp
func (c *ClientWithResponses) CreateEnvWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvResp, error) {
	rsp, err := c.CreateEnvWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvResp(rsp)
}

func (c *ClientWithResponses) CreateEnvWithResponse(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvResp, error) {
	rsp, err := c.CreateEnv(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvResp(rsp)
}

// DeleteEnvWithResponse request returning *DeleteEnvResp
func (c *ClientWithResponses) DeleteEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*DeleteEnvResp, error) {
	rsp, err := c.DeleteEnv(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvResp(rsp)
}

// GetEnvWithResponse request returning *GetEnvResp
func (c *ClientWithResponses) GetEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*GetEnvResp, error) {
	rsp, err := c.GetEnv(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvResp(rsp)
}

// UpdateEnvWithBodyWithResponse request with arbitrary body returning *UpdateEnvResp
func (c *ClientWithResponses) UpdateEnvWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error) {
	rsp, err := c.UpdateEnvWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvResp(rsp)
}

func (c *ClientWithResponses) UpdateEnvWithResponse(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error) {
	rsp, err := c.UpdateEnv(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvResp(rsp)
}

// EncryptSecretWithBodyWithResponse request with arbitrary body returning *EncryptSecretResp
func (c *ClientWithResponses) EncryptSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptSecretResp, error) {
	rsp, err := c.EncryptSecretWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptSecretResp(rsp)
}

func (c *ClientWithResponses) EncryptSecretWithResponse(ctx context.Context, env string, body EncryptSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptSecretResp, error) {
	rsp, err := c.EncryptSecret(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptSecretResp(rsp)
}

// DeleteLogoWithResponse request returning *DeleteLogoResp
func (c *ClientWithResponses) DeleteLogoWithResponse(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*DeleteLogoResp, error) {
	rsp, err := c.DeleteLogo(ctx, env, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogoResp(rsp)
}

// UploadLogoWithBodyWithResponse request with arbitrary body returning *UploadLogoResp
func (c *ClientWithResponses) UploadLogoWithBodyWithResponse(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogoResp, error) {
	rsp, err := c.UploadLogoWithBody(ctx, env, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLogoResp(rsp)
}

// GetEnvMicrometricsWithResponse request returning *GetEnvMicrometricsResp
func (c *ClientWithResponses) GetEnvMicrometricsWithResponse(ctx context.Context, env string, params *GetEnvMicrometricsParams, reqEditors ...RequestEditorFn) (*GetEnvMicrometricsResp, error) {
	rsp, err := c.GetEnvMicrometrics(ctx, env, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvMicrometricsResp(rsp)
}

// PresignRecoveryMicrositeURLWithBodyWithResponse request with arbitrary body returning *PresignRecoveryMicrositeURLResp
func (c *ClientWithResponses) PresignRecoveryMicrositeURLWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error) {
	rsp, err := c.PresignRecoveryMicrositeURLWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePresignRecoveryMicrositeURLResp(rsp)
}

func (c *ClientWithResponses) PresignRecoveryMicrositeURLWithResponse(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error) {
	rsp, err := c.PresignRecoveryMicrositeURL(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePresignRecoveryMicrositeURLResp(rsp)
}

// RefreshWebhookSecretWithBodyWithResponse request with arbitrary body returning *RefreshWebhookSecretResp
func (c *ClientWithResponses) RefreshWebhookSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error) {
	rsp, err := c.RefreshWebhookSecretWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshWebhookSecretResp(rsp)
}

func (c *ClientWithResponses) RefreshWebhookSecretWithResponse(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error) {
	rsp, err := c.RefreshWebhookSecret(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshWebhookSecretResp(rsp)
}

// ListEnvRequestsWithResponse request returning *ListEnvRequestsResp
func (c *ClientWithResponses) ListEnvRequestsWithResponse(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*ListEnvRequestsResp, error) {
	rsp, err := c.ListEnvRequests(ctx, env, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvRequestsResp(rsp)
}

// GetEnvRequestWithResponse request returning *GetEnvRequestResp
func (c *ClientWithResponses) GetEnvRequestWithResponse(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*GetEnvRequestResp, error) {
	rsp, err := c.GetEnvRequest(ctx, env, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvRequestResp(rsp)
}

// ListSlackIntegrationsWithResponse request returning *ListSlackIntegrationsResp
func (c *ClientWithResponses) ListSlackIntegrationsWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListSlackIntegrationsResp, error) {
	rsp, err := c.ListSlackIntegrations(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSlackIntegrationsResp(rsp)
}

// DeleteSlackIntegrationWithResponse request returning *DeleteSlackIntegrationResp
func (c *ClientWithResponses) DeleteSlackIntegrationWithResponse(ctx context.Context, env string, integration string, reqEditors ...RequestEditorFn) (*DeleteSlackIntegrationResp, error) {
	rsp, err := c.DeleteSlackIntegration(ctx, env, integration, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSlackIntegrationResp(rsp)
}

// CreateTemplateWithBodyWithResponse request with arbitrary body returning *CreateTemplateResp
func (c *ClientWithResponses) CreateTemplateWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error) {
	rsp, err := c.CreateTemplateWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResp(rsp)
}

func (c *ClientWithResponses) CreateTemplateWithResponse(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error) {
	rsp, err := c.CreateTemplate(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResp(rsp)
}

// DeleteTemplateWithResponse request returning *DeleteTemplateResp
func (c *ClientWithResponses) DeleteTemplateWithResponse(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*DeleteTemplateResp, error) {
	rsp, err := c.DeleteTemplate(ctx, env, template, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplateResp(rsp)
}

// UpdateTemplateWithBodyWithResponse request with arbitrary body returning *UpdateTemplateResp
func (c *ClientWithResponses) UpdateTemplateWithBodyWithResponse(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplateWithBody(ctx, env, template, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

func (c *ClientWithResponses) UpdateTemplateWithResponse(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplate(ctx, env, template, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

// ListWebhooksWithResponse request returning *ListWebhooksResp
func (c *ClientWithResponses) ListWebhooksWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListWebhooksResp, error) {
	rsp, err := c.ListWebhooks(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhooksResp(rsp)
}

// GetSlackRequestDetailsWithResponse request returning *GetSlackRequestDetailsResp
func (c *ClientWithResponses) GetSlackRequestDetailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSlackRequestDetailsResp, error) {
	rsp, err := c.GetSlackRequestDetails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSlackRequestDetailsResp(rsp)
}

// GetOrgWithResponse request returning *GetOrgResp
func (c *ClientWithResponses) GetOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrgResp, error) {
	rsp, err := c.GetOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgResp(rsp)
}

// UpdateOrgWithBodyWithResponse request with arbitrary body returning *UpdateOrgResp
func (c *ClientWithResponses) UpdateOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error) {
	rsp, err := c.UpdateOrgWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgResp(rsp)
}

func (c *ClientWithResponses) UpdateOrgWithResponse(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error) {
	rsp, err := c.UpdateOrg(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgResp(rsp)
}

// ListOrgMembersWithResponse request returning *ListOrgMembersResp
func (c *ClientWithResponses) ListOrgMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrgMembersResp, error) {
	rsp, err := c.ListOrgMembers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrgMembersResp(rsp)
}

// InviteOrgMemberWithBodyWithResponse request with arbitrary body returning *InviteOrgMemberResp
func (c *ClientWithResponses) InviteOrgMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error) {
	rsp, err := c.InviteOrgMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteOrgMemberResp(rsp)
}

func (c *ClientWithResponses) InviteOrgMemberWithResponse(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error) {
	rsp, err := c.InviteOrgMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteOrgMemberResp(rsp)
}

// RemoveOrgMemberWithResponse request returning *RemoveOrgMemberResp
func (c *ClientWithResponses) RemoveOrgMemberWithResponse(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*RemoveOrgMemberResp, error) {
	rsp, err := c.RemoveOrgMember(ctx, member, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOrgMemberResp(rsp)
}

// UpdateOrgMemberWithBodyWithResponse request with arbitrary body returning *UpdateOrgMemberResp
func (c *ClientWithResponses) UpdateOrgMemberWithBodyWithResponse(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error) {
	rsp, err := c.UpdateOrgMemberWithBody(ctx, member, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgMemberResp(rsp)
}

func (c *ClientWithResponses) UpdateOrgMemberWithResponse(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error) {
	rsp, err := c.UpdateOrgMember(ctx, member, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgMemberResp(rsp)
}

// CreateRequestWithBodyWithResponse request with arbitrary body returning *CreateRequestResp
func (c *ClientWithResponses) CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResp, error) {
	rsp, err := c.CreateRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResp(rsp)
}

func (c *ClientWithResponses) CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResp, error) {
	rsp, err := c.CreateRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResp(rsp)
}

// CancelRequestWithResponse request returning *CancelRequestResp
func (c *ClientWithResponses) CancelRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*CancelRequestResp, error) {
	rsp, err := c.CancelRequest(ctx, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelRequestResp(rsp)
}

// GetRequestWithResponse request returning *GetRequestResp
func (c *ClientWithResponses) GetRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*GetRequestResp, error) {
	rsp, err := c.GetRequest(ctx, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestResp(rsp)
}

// UpdateRequestWithBodyWithResponse request with arbitrary body returning *UpdateRequestResp
func (c *ClientWithResponses) UpdateRequestWithBodyWithResponse(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error) {
	rsp, err := c.UpdateRequestWithBody(ctx, requestID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResp(rsp)
}

func (c *ClientWithResponses) UpdateRequestWithResponse(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error) {
	rsp, err := c.UpdateRequest(ctx, requestID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResp(rsp)
}

// Oauth2AuthorizeWithResponse request returning *Oauth2AuthorizeResp
func (c *ClientWithResponses) Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResp, error) {
	rsp, err := c.Oauth2Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeResp(rsp)
}

// Oauth2AuthorizeIframeWithResponse request returning *Oauth2AuthorizeIframeResp
func (c *ClientWithResponses) Oauth2AuthorizeIframeWithResponse(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeIframeResp, error) {
	rsp, err := c.Oauth2AuthorizeIframe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeIframeResp(rsp)
}

// Oauth2AuthorizeWithRequestWithResponse request returning *Oauth2AuthorizeWithRequestResp
func (c *ClientWithResponses) Oauth2AuthorizeWithRequestWithResponse(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestResp, error) {
	rsp, err := c.Oauth2AuthorizeWithRequest(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithRequestResp(rsp)
}

// Oauth2LogoutWithResponse request returning *Oauth2LogoutResp
func (c *ClientWithResponses) Oauth2LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Oauth2LogoutResp, error) {
	rsp, err := c.Oauth2Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2LogoutResp(rsp)
}

// GetBulkPeoplePropertiesWithBodyWithResponse request with arbitrary body returning *GetBulkPeoplePropertiesResp
func (c *ClientWithResponses) GetBulkPeoplePropertiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error) {
	rsp, err := c.GetBulkPeoplePropertiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkPeoplePropertiesResp(rsp)
}

func (c *ClientWithResponses) GetBulkPeoplePropertiesWithResponse(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error) {
	rsp, err := c.GetBulkPeopleProperties(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkPeoplePropertiesResp(rsp)
}

// ComparePeopleWithBodyWithResponse request with arbitrary body returning *ComparePeopleResp
func (c *ClientWithResponses) ComparePeopleWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error) {
	rsp, err := c.ComparePeopleWithBody(ctx, subject, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComparePeopleResp(rsp)
}

func (c *ClientWithResponses) ComparePeopleWithResponse(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error) {
	rsp, err := c.ComparePeople(ctx, subject, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComparePeopleResp(rsp)
}

// CompareSelfieWithBodyWithResponse request with arbitrary body returning *CompareSelfieResp
func (c *ClientWithResponses) CompareSelfieWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompareSelfieResp, error) {
	rsp, err := c.CompareSelfieWithBody(ctx, subject, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompareSelfieResp(rsp)
}

// DeletePersonPropertiesWithResponse request returning *DeletePersonPropertiesResp
func (c *ClientWithResponses) DeletePersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*DeletePersonPropertiesResp, error) {
	rsp, err := c.DeletePersonProperties(ctx, subject, scopes, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonPropertiesResp(rsp)
}

// GetPersonPropertiesWithResponse request returning *GetPersonPropertiesResp
func (c *ClientWithResponses) GetPersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersonPropertiesResp, error) {
	rsp, err := c.GetPersonProperties(ctx, subject, scopes, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonPropertiesResp(rsp)
}

// Oauth2TokenWithBodyWithResponse request with arbitrary body returning *Oauth2TokenResp
func (c *ClientWithResponses) Oauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error) {
	rsp, err := c.Oauth2TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenResp(rsp)
}

func (c *ClientWithResponses) Oauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error) {
	rsp, err := c.Oauth2TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenResp(rsp)
}

// Oauth2AuthorizeWithExperienceWithResponse request returning *Oauth2AuthorizeWithExperienceResp
func (c *ClientWithResponses) Oauth2AuthorizeWithExperienceWithResponse(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithExperienceResp, error) {
	rsp, err := c.Oauth2AuthorizeWithExperience(ctx, experience, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithExperienceResp(rsp)
}

// Oauth2AuthorizeWithRequestAndExperienceWithResponse request returning *Oauth2AuthorizeWithRequestAndExperienceResp
func (c *ClientWithResponses) Oauth2AuthorizeWithRequestAndExperienceWithResponse(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestAndExperienceResp, error) {
	rsp, err := c.Oauth2AuthorizeWithRequestAndExperience(ctx, experience, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithRequestAndExperienceResp(rsp)
}

// ParseBulkUploadAccountPhotosResp parses an HTTP response from a BulkUploadAccountPhotosWithResponse call
func ParseBulkUploadAccountPhotosResp(rsp *http.Response) (*BulkUploadAccountPhotosResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadAccountPhotosResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkUploadAccountPhotosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAccountsResp parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResp(rsp *http.Response) (*ListAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateAccountsResp parses an HTTP response from a BulkUpdateAccountsWithResponse call
func ParseBulkUpdateAccountsResp(rsp *http.Response) (*BulkUpdateAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountBulkUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAccountResp parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResp(rsp *http.Response) (*GetAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAccountResp parses an HTTP response from a UpdateAccountWithResponse call
func ParseUpdateAccountResp(rsp *http.Response) (*UpdateAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadAccountPhotoResp parses an HTTP response from a UploadAccountPhotoWithResponse call
func ParseUploadAccountPhotoResp(rsp *http.Response) (*UploadAccountPhotoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAccountPhotoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAPIKeysResp parses an HTTP response from a ListAPIKeysWithResponse call
func ParseListAPIKeysResp(rsp *http.Response) (*ListAPIKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPIKeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAPIKeyResp parses an HTTP response from a CreateAPIKeyWithResponse call
func ParseCreateAPIKeyResp(rsp *http.Response) (*CreateAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAPIKeyResp parses an HTTP response from a DeleteAPIKeyWithResponse call
func ParseDeleteAPIKeyResp(rsp *http.Response) (*DeleteAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAPIKeyResp parses an HTTP response from a GetAPIKeyWithResponse call
func ParseGetAPIKeyResp(rsp *http.Response) (*GetAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAPIKeyResp parses an HTTP response from a UpdateAPIKeyWithResponse call
func ParseUpdateAPIKeyResp(rsp *http.Response) (*UpdateAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAuditEventsResp parses an HTTP response from a ListAuditEventsWithResponse call
func ParseListAuditEventsResp(rsp *http.Response) (*ListAuditEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAuditEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2CancelResp parses an HTTP response from a Oauth2CancelWithResponse call
func ParseOauth2CancelResp(rsp *http.Response) (*Oauth2CancelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2CancelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2PollResp parses an HTTP response from a Oauth2PollWithResponse call
func ParseOauth2PollResp(rsp *http.Response) (*Oauth2PollResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2PollResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDirectoriesResp parses an HTTP response from a ListDirectoriesWithResponse call
func ParseListDirectoriesResp(rsp *http.Response) (*ListDirectoriesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectoriesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDirectoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDirectoryResp parses an HTTP response from a CreateDirectoryWithResponse call
func ParseCreateDirectoryResp(rsp *http.Response) (*CreateDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateDirectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDirectoryResp parses an HTTP response from a DeleteDirectoryWithResponse call
func ParseDeleteDirectoryResp(rsp *http.Response) (*DeleteDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDirectoryResp parses an HTTP response from a GetDirectoryWithResponse call
func ParseGetDirectoryResp(rsp *http.Response) (*GetDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Directory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateDirectoryResp parses an HTTP response from a UpdateDirectoryWithResponse call
func ParseUpdateDirectoryResp(rsp *http.Response) (*UpdateDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Directory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDirectoryAuthorizationURLResp parses an HTTP response from a GetDirectoryAuthorizationURLWithResponse call
func ParseGetDirectoryAuthorizationURLResp(rsp *http.Response) (*GetDirectoryAuthorizationURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDirectoryAuthorizationURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuth2AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetDirectoryCredentialsResp parses an HTTP response from a SetDirectoryCredentialsWithResponse call
func ParseSetDirectoryCredentialsResp(rsp *http.Response) (*SetDirectoryCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDirectoryCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDirectoryLogoResp parses an HTTP response from a DeleteDirectoryLogoWithResponse call
func ParseDeleteDirectoryLogoResp(rsp *http.Response) (*DeleteDirectoryLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectoryLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUploadDirectoryLogoResp parses an HTTP response from a UploadDirectoryLogoWithResponse call
func ParseUploadDirectoryLogoResp(rsp *http.Response) (*UploadDirectoryLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadDirectoryLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRegenerateDirectoryAgentTokenResp parses an HTTP response from a RegenerateDirectoryAgentTokenWithResponse call
func ParseRegenerateDirectoryAgentTokenResp(rsp *http.Response) (*RegenerateDirectoryAgentTokenResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateDirectoryAgentTokenResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegenerateDirectoryAgentTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSyncDirectoryResp parses an HTTP response from a SyncDirectoryWithResponse call
func ParseSyncDirectoryResp(rsp *http.Response) (*SyncDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEnvsResp parses an HTTP response from a ListEnvsWithResponse call
func ParseListEnvsResp(rsp *http.Response) (*ListEnvsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEnvsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateEnvResp parses an HTTP response from a CreateEnvWithResponse call
func ParseCreateEnvResp(rsp *http.Response) (*CreateEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateEnvResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteEnvResp parses an HTTP response from a DeleteEnvWithResponse call
func ParseDeleteEnvResp(rsp *http.Response) (*DeleteEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnvResp parses an HTTP response from a GetEnvWithResponse call
func ParseGetEnvResp(rsp *http.Response) (*GetEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Env
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateEnvResp parses an HTTP response from a UpdateEnvWithResponse call
func ParseUpdateEnvResp(rsp *http.Response) (*UpdateEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseEncryptSecretResp parses an HTTP response from a EncryptSecretWithResponse call
func ParseEncryptSecretResp(rsp *http.Response) (*EncryptSecretResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptSecretResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteLogoResp parses an HTTP response from a DeleteLogoWithResponse call
func ParseDeleteLogoResp(rsp *http.Response) (*DeleteLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUploadLogoResp parses an HTTP response from a UploadLogoWithResponse call
func ParseUploadLogoResp(rsp *http.Response) (*UploadLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnvMicrometricsResp parses an HTTP response from a GetEnvMicrometricsWithResponse call
func ParseGetEnvMicrometricsResp(rsp *http.Response) (*GetEnvMicrometricsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvMicrometricsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMicrometricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePresignRecoveryMicrositeURLResp parses an HTTP response from a PresignRecoveryMicrositeURLWithResponse call
func ParsePresignRecoveryMicrositeURLResp(rsp *http.Response) (*PresignRecoveryMicrositeURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PresignRecoveryMicrositeURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryMicrositePresignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRefreshWebhookSecretResp parses an HTTP response from a RefreshWebhookSecretWithResponse call
func ParseRefreshWebhookSecretResp(rsp *http.Response) (*RefreshWebhookSecretResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshWebhookSecretResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshWebhookSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEnvRequestsResp parses an HTTP response from a ListEnvRequestsWithResponse call
func ParseListEnvRequestsResp(rsp *http.Response) (*ListEnvRequestsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvRequestsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnvRequestResp parses an HTTP response from a GetEnvRequestWithResponse call
func ParseGetEnvRequestResp(rsp *http.Response) (*GetEnvRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListSlackIntegrationsResp parses an HTTP response from a ListSlackIntegrationsWithResponse call
func ParseListSlackIntegrationsResp(rsp *http.Response) (*ListSlackIntegrationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSlackIntegrationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSlackIntegrationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteSlackIntegrationResp parses an HTTP response from a DeleteSlackIntegrationWithResponse call
func ParseDeleteSlackIntegrationResp(rsp *http.Response) (*DeleteSlackIntegrationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSlackIntegrationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateTemplateResp parses an HTTP response from a CreateTemplateWithResponse call
func ParseCreateTemplateResp(rsp *http.Response) (*CreateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteTemplateResp parses an HTTP response from a DeleteTemplateWithResponse call
func ParseDeleteTemplateResp(rsp *http.Response) (*DeleteTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateTemplateResp parses an HTTP response from a UpdateTemplateWithResponse call
func ParseUpdateTemplateResp(rsp *http.Response) (*UpdateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListWebhooksResp parses an HTTP response from a ListWebhooksWithResponse call
func ParseListWebhooksResp(rsp *http.Response) (*ListWebhooksResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhooksResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhooksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetSlackRequestDetailsResp parses an HTTP response from a GetSlackRequestDetailsWithResponse call
func ParseGetSlackRequestDetailsResp(rsp *http.Response) (*GetSlackRequestDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSlackRequestDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SlackRequestDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOrgResp parses an HTTP response from a GetOrgWithResponse call
func ParseGetOrgResp(rsp *http.Response) (*GetOrgResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrgResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOrgResp parses an HTTP response from a UpdateOrgWithResponse call
func ParseUpdateOrgResp(rsp *http.Response) (*UpdateOrgResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrgResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListOrgMembersResp parses an HTTP response from a ListOrgMembersWithResponse call
func ParseListOrgMembersResp(rsp *http.Response) (*ListOrgMembersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrgMembersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOrgMembersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInviteOrgMemberResp parses an HTTP response from a InviteOrgMemberWithResponse call
func ParseInviteOrgMemberResp(rsp *http.Response) (*InviteOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRemoveOrgMemberResp parses an HTTP response from a RemoveOrgMemberWithResponse call
func ParseRemoveOrgMemberResp(rsp *http.Response) (*RemoveOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOrgMemberResp parses an HTTP response from a UpdateOrgMemberWithResponse call
func ParseUpdateOrgMemberResp(rsp *http.Response) (*UpdateOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateRequestResp parses an HTTP response from a CreateRequestWithResponse call
func ParseCreateRequestResp(rsp *http.Response) (*CreateRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCancelRequestResp parses an HTTP response from a CancelRequestWithResponse call
func ParseCancelRequestResp(rsp *http.Response) (*CancelRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestResp parses an HTTP response from a GetRequestWithResponse call
func ParseGetRequestResp(rsp *http.Response) (*GetRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateRequestResp parses an HTTP response from a UpdateRequestWithResponse call
func ParseUpdateRequestResp(rsp *http.Response) (*UpdateRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2AuthorizeResp parses an HTTP response from a Oauth2AuthorizeWithResponse call
func ParseOauth2AuthorizeResp(rsp *http.Response) (*Oauth2AuthorizeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/html) unsupported

	case rsp.StatusCode == 400:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseOauth2AuthorizeIframeResp parses an HTTP response from a Oauth2AuthorizeIframeWithResponse call
func ParseOauth2AuthorizeIframeResp(rsp *http.Response) (*Oauth2AuthorizeIframeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeIframeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOauth2AuthorizeWithRequestResp parses an HTTP response from a Oauth2AuthorizeWithRequestWithResponse call
func ParseOauth2AuthorizeWithRequestResp(rsp *http.Response) (*Oauth2AuthorizeWithRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOauth2LogoutResp parses an HTTP response from a Oauth2LogoutWithResponse call
func ParseOauth2LogoutResp(rsp *http.Response) (*Oauth2LogoutResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2LogoutResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBulkPeoplePropertiesResp parses an HTTP response from a GetBulkPeoplePropertiesWithResponse call
func ParseGetBulkPeoplePropertiesResp(rsp *http.Response) (*GetBulkPeoplePropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBulkPeoplePropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseComparePeopleResp parses an HTTP response from a ComparePeopleWithResponse call
func ParseComparePeopleResp(rsp *http.Response) (*ComparePeopleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ComparePeopleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComparisonResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCompareSelfieResp parses an HTTP response from a CompareSelfieWithResponse call
func ParseCompareSelfieResp(rsp *http.Response) (*CompareSelfieResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompareSelfieResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompareSelfieResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeletePersonPropertiesResp parses an HTTP response from a DeletePersonPropertiesWithResponse call
func ParseDeletePersonPropertiesResp(rsp *http.Response) (*DeletePersonPropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonPropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPersonPropertiesResp parses an HTTP response from a GetPersonPropertiesWithResponse call
func ParseGetPersonPropertiesResp(rsp *http.Response) (*GetPersonPropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonPropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PropertiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2TokenResp parses an HTTP response from a Oauth2TokenWithResponse call
func ParseOauth2TokenResp(rsp *http.Response) (*Oauth2TokenResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2TokenResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest TokenResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2AuthorizeWithExperienceResp parses an HTTP response from a Oauth2AuthorizeWithExperienceWithResponse call
func ParseOauth2AuthorizeWithExperienceResp(rsp *http.Response) (*Oauth2AuthorizeWithExperienceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithExperienceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/html) unsupported

	case rsp.StatusCode == 400:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseOauth2AuthorizeWithRequestAndExperienceResp parses an HTTP response from a Oauth2AuthorizeWithRequestAndExperienceWithResponse call
func ParseOauth2AuthorizeWithRequestAndExperienceResp(rsp *http.Response) (*Oauth2AuthorizeWithRequestAndExperienceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithRequestAndExperienceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
