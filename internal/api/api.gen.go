// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
	NoneScopes   = "none.Scopes"
)

// Defines values for AccountBulkUpdateStatus.
const (
	AccountBulkUpdateItemStatusBadRequest AccountBulkUpdateStatus = 400
	AccountBulkUpdateItemStatusConflict   AccountBulkUpdateStatus = 409
	AccountBulkUpdateItemStatusNotFound   AccountBulkUpdateStatus = 404
	AccountBulkUpdateItemStatusOK         AccountBulkUpdateStatus = 204
)

// Defines values for AuthorizeReturn.
const (
	AuthorizeReturnChrome  AuthorizeReturn = "chrome"
	AuthorizeReturnFirefox AuthorizeReturn = "firefox"
	AuthorizeReturnHTTPS   AuthorizeReturn = "https"
	AuthorizeReturnNone    AuthorizeReturn = ""
)

// Defines values for AuthorizeStatus.
const (
	AuthorizeStatusComplete AuthorizeStatus = 200
	AuthorizeStatusExpired  AuthorizeStatus = 510
	AuthorizeStatusPending  AuthorizeStatus = 100
	AuthorizeStatusRejected AuthorizeStatus = 403
)

// Defines values for BadRequestResponseStatus.
const (
	BadRequestResponseStatusN400 BadRequestResponseStatus = 400
)

// Defines values for DirectoryKind.
const (
	DirectoryKindAzureAD  DirectoryKind = "azure-ad"
	DirectoryKindDuo      DirectoryKind = "duo"
	DirectoryKindOkta     DirectoryKind = "okta"
	DirectoryKindOnelogin DirectoryKind = "onelogin"
)

// Defines values for GovtidType.
const (
	DriverLicense GovtidType = "driver_license"
	Passport      GovtidType = "passport"
)

// Defines values for LogoKind.
const (
	Install LogoKind = "install"
	Mobile  LogoKind = "mobile"
	Qr      LogoKind = "qr"
)

// Defines values for NumericRequestStatus.
const (
	NumericRequestStatusCancelled        NumericRequestStatus = 404
	NumericRequestStatusCompleted        NumericRequestStatus = 200
	NumericRequestStatusExpired          NumericRequestStatus = 410
	NumericRequestStatusExpiredScopes    NumericRequestStatus = 411
	NumericRequestStatusInProgress       NumericRequestStatus = 101
	NumericRequestStatusPending          NumericRequestStatus = 100
	NumericRequestStatusRejectedFraud    NumericRequestStatus = 552
	NumericRequestStatusRejectedInReview NumericRequestStatus = 550
	NumericRequestStatusRejectedUnusable NumericRequestStatus = 551
	NumericRequestStatusRevoked          NumericRequestStatus = 403
)

// Defines values for RecoveryMicrositeFlow.
const (
	Enroll  RecoveryMicrositeFlow = "enroll"
	Recover RecoveryMicrositeFlow = "recover"
)

// Defines values for RecoveryMicrositeOperation.
const (
	Mfa                 RecoveryMicrositeOperation = "mfa"
	Password            RecoveryMicrositeOperation = "password"
	TemporaryAccessPass RecoveryMicrositeOperation = "temporary-access-pass"
	Unlock              RecoveryMicrositeOperation = "unlock"
)

// Defines values for RecoveryPolicy.
const (
	RecoveryPolicyDisabled         RecoveryPolicy = "disabled"
	RecoveryPolicyNameAndBirthDate RecoveryPolicy = "name_and_birth_date"
	RecoveryPolicyNameMatch        RecoveryPolicy = "name_match"
	RecoveryPolicyPhoto            RecoveryPolicy = "photo"
)

// Defines values for RequestProgress.
const (
	RequestProgressAppOpened    RequestProgress = "app_opened"
	RequestProgressConsentGiven RequestProgress = "consent_given"
	RequestProgressFaceScanned  RequestProgress = "face_scanned"
	RequestProgressIDScanned    RequestProgress = "id_scanned"
	RequestProgressInit         RequestProgress = "created"
	RequestProgressLinkOpened   RequestProgress = "link_opened"
)

// Defines values for RequestStatus.
const (
	RequestStatusCancelled        RequestStatus = "cancelled"
	RequestStatusExpired          RequestStatus = "expired"
	RequestStatusExpiredScopes    RequestStatus = "expired_scopes"
	RequestStatusInProgress       RequestStatus = "in_progress"
	RequestStatusPending          RequestStatus = "pending"
	RequestStatusPersonDeleted    RequestStatus = "person_deleted"
	RequestStatusRejectedFraud    RequestStatus = "rejected_fraud"
	RequestStatusRejectedInReview RequestStatus = "rejected_appealed"
	RequestStatusRejectedUnusable RequestStatus = "rejected_unusable"
	RequestStatusRevoked          RequestStatus = "revoked"
	RequestStatusShared           RequestStatus = "shared"
)

// Defines values for Role.
const (
	RoleAdmin       Role = "admin"
	RoleLimited     Role = "limited"
	RoleLimitedPlus Role = "limited_plus"
	RoleOwner       Role = "owner"
	RoleUser        Role = "user"
)

// Defines values for Scope.
const (
	Login             Scope = "login"
	NtAddress         Scope = "nt:address"
	NtAgeOver18       Scope = "nt:age_over_18"
	NtAgeOver21       Scope = "nt:age_over_21"
	NtBirthDate       Scope = "nt:birth_date"
	NtEmail           Scope = "nt:email"
	NtEmailUnverified Scope = "nt:email:unverified"
	NtFirstName       Scope = "nt:first_name"
	NtGovtidDetails   Scope = "nt:govtid_details"
	NtLastName        Scope = "nt:last_name"
	NtLegalFirstName  Scope = "nt:legal_first_name"
	NtLegalLastName   Scope = "nt:legal_last_name"
	NtLegalName       Scope = "nt:legal_name"
	NtLocationIp      Scope = "nt:location:ip"
	NtName            Scope = "nt:name"
	NtPhone           Scope = "nt:phone"
	NtProfilePicture  Scope = "nt:profile_picture"
	Openid            Scope = "openid"
)

// Defines values for TokenRequestGrantType.
const (
	AuthorizationCode TokenRequestGrantType = "authorization_code"
)

// Defines values for TokenResponseTokenType.
const (
	TokenTypeBearer TokenResponseTokenType = "Bearer"
)

// Defines values for WebhookEventType.
const (
	WebhookEventTypeRecover WebhookEventType = "recover"
	WebhookEventTypeReject  WebhookEventType = "reject"
	WebhookEventTypeRequest WebhookEventType = "request"
	WebhookEventTypeShare   WebhookEventType = "share"
)

// Defines values for ListAccountsParamsSort.
const (
	AccountBoundAt      ListAccountsParamsSort = "account_bound_at"
	ExternalId          ListAccountsParamsSort = "external_id"
	LastVerifiedAt      ListAccountsParamsSort = "last_verified_at"
	MinusAccountBoundAt ListAccountsParamsSort = "-account_bound_at"
	MinusExternalId     ListAccountsParamsSort = "-external_id"
	MinusLastVerifiedAt ListAccountsParamsSort = "-last_verified_at"
	MinusName           ListAccountsParamsSort = "-name"
	Name                ListAccountsParamsSort = "name"
)

// Defines values for ListEnvRequestsParamsSort.
const (
	LastCreated      ListEnvRequestsParamsSort = "last_created"
	LastUpdated      ListEnvRequestsParamsSort = "last_updated"
	MinusLastCreated ListEnvRequestsParamsSort = "-last_created"
	MinusLastUpdated ListEnvRequestsParamsSort = "-last_updated"
)

// Defines values for ListEnvRequestsParamsStatusFilter.
const (
	Active               ListEnvRequestsParamsStatusFilter = "active"
	Expired              ListEnvRequestsParamsStatusFilter = "expired"
	ScheduledForDeletion ListEnvRequestsParamsStatusFilter = "scheduledForDeletion"
)

// Defines values for ListEnvRequestsParamsUpdatedAt.
const (
	All       ListEnvRequestsParamsUpdatedAt = "all"
	Lastmonth ListEnvRequestsParamsUpdatedAt = "lastmonth"
	Month     ListEnvRequestsParamsUpdatedAt = "month"
	Today     ListEnvRequestsParamsUpdatedAt = "today"
	Week      ListEnvRequestsParamsUpdatedAt = "week"
	Year      ListEnvRequestsParamsUpdatedAt = "year"
)

// Defines values for Oauth2AuthorizeParamsResponseType.
const (
	Oauth2AuthorizeParamsResponseTypeCode Oauth2AuthorizeParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeParamsResponseMode.
const (
	Oauth2AuthorizeParamsResponseModeFragment Oauth2AuthorizeParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeParamsCodeChallengeMethod.
const (
	Oauth2AuthorizeParamsCodeChallengeMethodPlain Oauth2AuthorizeParamsCodeChallengeMethod = "plain"
	Oauth2AuthorizeParamsCodeChallengeMethodS256  Oauth2AuthorizeParamsCodeChallengeMethod = "S256"
)

// Defines values for Oauth2AuthorizeIframeParamsResponseType.
const (
	Oauth2AuthorizeIframeParamsResponseTypeCode Oauth2AuthorizeIframeParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeIframeParamsResponseMode.
const (
	Oauth2AuthorizeIframeParamsResponseModeFragment Oauth2AuthorizeIframeParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeIframeParamsCodeChallengeMethod.
const (
	Oauth2AuthorizeIframeParamsCodeChallengeMethodPlain Oauth2AuthorizeIframeParamsCodeChallengeMethod = "plain"
	Oauth2AuthorizeIframeParamsCodeChallengeMethodS256  Oauth2AuthorizeIframeParamsCodeChallengeMethod = "S256"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsResponseType.
const (
	Code Oauth2AuthorizeWithExperienceParamsResponseType = "code"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsResponseMode.
const (
	Fragment Oauth2AuthorizeWithExperienceParamsResponseMode = "fragment"
)

// Defines values for Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod.
const (
	Plain Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod = "plain"
	S256  Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod = "S256"
)

// AccountBulkUpdateStatus A status code that describes whether the operation was successful
type AccountBulkUpdateStatus int

// APIKey defines model for APIKey.
type APIKey struct {
	// ID The unique identifier for the API key
	ID string `json:"id"`

	// Name A descriptive name for the API key
	Name string `json:"name"`

	// CreatedAt When the API key was created
	CreatedAt time.Time `json:"created_at"`
	Enabled   bool      `json:"enabled"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs"`
	Role   Role     `json:"role"`
}

// APIKeyUpdateRequest defines model for APIKeyUpdateRequest.
type APIKeyUpdateRequest struct {
	// Name A descriptive name for the API key
	Name *string `json:"name,omitempty"`

	// Enabled `true` if the API key is enabled, or `false` if it cannot be used.
	Enabled *bool `json:"enabled,omitempty"`
	Role    *Role `json:"role,omitempty"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs,omitempty"`
}

// Account defines model for Account.
type Account struct {
	// ID The Nametag identifier for the account.
	ID string `json:"id"`

	// DirectoryIdentifiers The identifiers for the account used by the directory (typically an email address, username)
	DirectoryIdentifiers []string `json:"directory_identifiers"`

	// DirectoryImmutableIdentifier The unchanging identifier for the account used by the directory. Most directories have an UUID or other opaque identifier that doesn't change even when `directory_identifiers` changes.
	DirectoryImmutableIdentifier string `json:"directory_immutable_identifier"`

	// Name The person's name, according to the directory
	Name string `json:"name"`

	// Subject The Nametag Subject for this person, if the account has been bound to a `subject`. Null otherwise.
	Subject *string `json:"subject,omitempty"`

	// HaveBirthDate true if the person's expected birth date has been set for the directory.
	HaveBirthDate *bool         `json:"have_birth_date,omitempty"`
	Photo         *AccountPhoto `json:"photo,omitempty"`
}

// AccountBulkUpdateRequest defines model for AccountBulkUpdateRequest.
type AccountBulkUpdateRequest struct {
	// Accounts A list of account update operations
	Accounts []AccountBulkUpdateRequestItem `json:"accounts"`
}

// AccountBulkUpdateRequestItem defines model for AccountBulkUpdateRequestItem.
type AccountBulkUpdateRequestItem struct {
	// Subject The subject for this person. Set this to an empty string to remove the binding for this person.
	Subject *string `json:"subject,omitempty"`

	// BirthDate The subject's date of birth. If this is set prior to the account being bound to a `subject`, then the birth  date on their ID must match this date. You can also specify the hash or HMAC of the person's birth date.  See [Birth date hashes](/docs/birth-date-hash) for details.
	BirthDate *string `json:"birth_date,omitempty"`

	// ID The unique identifier of the account. This can be the Nametag ID
	// for the account, the immutable ID of the account (e.g. the GUID in
	// Azure AD), or one of the identifiers associated with the account,
	// (e.g. the email address, username, or UPN).
	ID string `json:"id"`
}

// AccountBulkUpdateResponse defines model for AccountBulkUpdateResponse.
type AccountBulkUpdateResponse struct {
	Results []AccountBulkUpdateResponseItem `json:"results"`
}

// AccountBulkUpdateResponseItem The status of each operation specified in the request
type AccountBulkUpdateResponseItem struct {
	// ID The account identifier provided in the request
	ID string `json:"id"`

	// Status A status code that describes whether the operation was successful
	Status AccountBulkUpdateStatus `json:"status"`

	// Error A description of the error that occurred.
	Error *string `json:"error,omitempty"`
}

// AccountPhoto defines model for AccountPhoto.
type AccountPhoto struct {
	// SHA256 The SHA256 hash of the uploaded image.
	SHA256 string `json:"sha256"`

	// CreatedAt The time when the image was added.
	CreatedAt time.Time `json:"created_at"`
}

// AccountUpdateRequest defines model for AccountUpdateRequest.
type AccountUpdateRequest struct {
	// Subject The subject for this person. Set this to an empty string to remove the binding for this person.
	Subject *string `json:"subject,omitempty"`

	// BirthDate The subject's date of birth. If this is set prior to the account being bound to a `subject`, then the birth  date on their ID must match this date.
	// You can also specify the hash or HMAC of the person's birth date. See [Birth date hashes](/docs/birth-date-hash) for details.
	BirthDate *string `json:"birth_date,omitempty"`
}

// AccountsList defines model for AccountsList.
type AccountsList struct {
	// Accounts The list of accounts
	Accounts []Account `json:"accounts"`
}

// AuthorizeResponse defines model for AuthorizeResponse.
type AuthorizeResponse struct {
	ErrorMessage      string          `json:"error_message,omitempty"`
	RedirectURI       string          `json:"redirect_uri,omitempty"`
	EnvName           string          `json:"env_name,omitempty"`
	QRCode            []byte          `json:"qrcode,omitempty"`
	InstallTicket     string          `json:"install_ticket,omitempty"`
	RequestID         string          `json:"request,omitempty"`
	SessionToken      string          `json:"session_token,omitempty"`
	AppClipExperience string          `json:"app_clip_experience,omitempty"`
	Return            AuthorizeReturn `json:"return"`
}

// AuthorizeReturn defines model for AuthorizeReturn.
type AuthorizeReturn string

// AuthorizeStatus defines model for AuthorizeStatus.
type AuthorizeStatus int

// BadRequestResponse defines model for BadRequestResponse.
type BadRequestResponse struct {
	// Status The status code for the request. Always 400, meaning the request was invalid
	Status BadRequestResponseStatus `json:"status"`

	// Errors A set of descriptive error messages that caused the request to be invalid
	Errors []string `json:"errors"`
}

// BadRequestResponseStatus The status code for the request. Always 400, meaning the request was invalid
type BadRequestResponseStatus int

// BulkRequest defines model for BulkRequest.
type BulkRequest struct {
	// Requests A list of property requests, one for each person about whom you are requesting information.
	Requests []BulkRequestItem `json:"requests"`
}

// BulkRequestItem defines model for BulkRequestItem.
type BulkRequestItem struct {
	// Subject The subject of the request. This is the person whose properties are being requested.
	Subject string `json:"subject"`

	// Scopes Which scopes you are requesting for this person.
	Scopes []Scope `json:"scopes"`
}

// BulkResponse defines model for BulkResponse.
type BulkResponse struct {
	// Responses A list of responses for each person requested.
	Responses []PropertiesResponse `json:"data"`
}

// BulkUploadAccountPhotosResponse defines model for BulkUploadAccountPhotosResponse.
type BulkUploadAccountPhotosResponse struct {
	// Files A list of responses, each corresponding to a file in the uploaded archive.
	Files []BulkUploadAccountPhotosResponseItem `json:"files"`
}

// BulkUploadAccountPhotosResponseItem defines model for BulkUploadAccountPhotosResponseItem.
type BulkUploadAccountPhotosResponseItem struct {
	// Filename The name of the file
	Filename string `json:"filename"`

	// AccountID The Nametag identifier for the account that matched this file. If this field is absent, then  the file was not matched to an existing account.
	AccountID *string `json:"account_id,omitempty"`

	// DirectoryIdentifiers The identifiers for the account used by the directory (typically an email address, username)
	DirectoryIdentifiers *[]string `json:"directory_identifiers,omitempty"`

	// DirectoryImmutableIdentifier The unchanging identifier for the account used by the directory. Most directories have an UUID or other opaque identifier that doesn't change even when `directory_identifiers` changes.
	DirectoryImmutableIdentifier *string `json:"directory_immutable_identifier,omitempty"`

	// Status This field is 200 if adding the photo was successful, 404 if an account could not be found,  400 if the image is invalid, or 422 if the image contains multiple faces, doesn't match the existing selfie, or no face at all.
	Status int `json:"status"`

	// Error A human readable error message describing the reason a file could not be processed.
	Error *string `json:"error,omitempty"`
}

// CancelResponse defines model for CancelResponse.
type CancelResponse struct {
	RedirectURI string `json:"redirect_uri"`
}

// CompareSelfieResult defines model for CompareSelfieResult.
type CompareSelfieResult struct {
	// Match True if the `match_confidence` exceeds Nametag's recommended threshold for a match, false otherwise.
	Match bool `json:"match"`

	// Confidence A number between 0 and 1 that represents Nametag's confidence that the values match. A value of 1 means Nametag is very confident that the values match, while 0 means that the values do not match at all.
	Confidence float64 `json:"confidence"`
}

// Comparison defines model for Comparison.
type Comparison struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the developer console.
	Scope Scope `json:"scope"`

	// Expected The expected value for this scope.
	Expected string `json:"expected"`

	// Actual The actual value for this scope.
	Actual string `json:"actual"`

	// Match True if the `match_confidence` exceeds Nametag's recommended threshold for a match, false otherwise.
	Match bool `json:"match"`

	// MatchConfidence A number between 0 and 1 that represents Nametag's confidence that the values match. A value of 1 means Nametag is very confident that the values match, while 0 means that the values do not match at all.
	MatchConfidence float64 `json:"match_confidence"`
}

// ComparisonResult defines model for ComparisonResult.
type ComparisonResult struct {
	// Confidence A number between 0 and 1 that represents Nametag's confidence that the value matches the expected value. A value of 1 means Nametag is very confident that the values match,  while 0 means that the values do not match at all.
	Confidence float64 `json:"confidence"`

	// Comparisons A list of comparisons between the expected and actual values.
	Comparisons []Comparison `json:"comparisons"`
}

// CreateAPIKeyRequest defines model for CreateAPIKeyRequest.
type CreateAPIKeyRequest struct {
	// Name A descriptive name for the API key
	Name string `json:"name,omitempty"`

	// Enabled `true` if the API key is enabled, or `false` if it cannot be used.
	Enabled bool `json:"enabled,omitempty"`

	// EnvIDs The unique identifier for the environments this API key belongs to, or `["*"]` if the key applies to all environments.
	EnvIDs []string `json:"envs"`
	Role   *Role    `json:"role,omitempty"`
}

// CreateAPIKeyResponse defines model for CreateAPIKeyResponse.
type CreateAPIKeyResponse struct {
	// ID The unique identifier for the API key
	ID string `json:"id"`

	// Key The full secret API key
	Key string `json:"key"`
}

// CreateDirectoryRequest defines model for CreateDirectoryRequest.
type CreateDirectoryRequest struct {
	// Env The ID of the environment to create this directory for
	Env string `json:"env"`

	// Kind The type of the directory connection.
	Kind        DirectoryKind `json:"kind"`
	Credentials *Credentials  `json:"credentials,omitempty"`
}

// CreateDirectoryResponse defines model for CreateDirectoryResponse.
type CreateDirectoryResponse struct {
	// ID The unique identifier for the directory.
	ID string `json:"id"`

	// RedirectURL The OAuth 2.0 redirect URL to authorize the directory.
	//
	// If the directory uses OAuth 2.0 for authorization (e.g. `"azure-ad"`), then
	// this field contains the URL to redirect the user to authorize the directory.
	RedirectURL *string `json:"redirect_url,omitempty"`
}

// CreateEnvRequest defines model for CreateEnvRequest.
type CreateEnvRequest = map[string]interface{}

// CreateEnvResponse defines model for CreateEnvResponse.
type CreateEnvResponse struct {
	// ID The unique identifier of the environment
	ID string `json:"id"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	// EnvID The ID of the environment associated with the request.
	EnvID string `json:"env"`

	// Scopes A list of the information (scopes) that the request is asking for.
	// If you specify `template`, you must not specify `scopes`.
	Scopes []Scope `json:"scopes,omitempty"`

	// Template The name of a template that customizes how the request is presented to the user.
	//
	// Because a template contains it's own scope definitions, you must not specify `scopes` when you specify `template`.
	Template string `json:"template,omitempty"`

	// ExpiresAt The last time this request will be valid. After this time, the request is expired and the user will no longer be able to complete it. This cannot be used with `ttl`.
	ExpiresAt time.Time `json:"expires_at,omitempty"`

	// Phone The phone number to which the request link should be sent.
	Phone string `json:"phone,omitempty"`

	// Whatsapp The Whatsapp phone number to which the request link should be sent.
	Whatsapp string `json:"whatsapp,omitempty"`

	// Label An internal label for this request. You can use this field to help you track the request in your own systems. Nametag stores this field, but does not process it at
	Label string `json:"label,omitempty"`
}

// CreateRequestResponse defines model for CreateRequestResponse.
type CreateRequestResponse struct {
	// ID A unique identifier for the request
	ID     string               `json:"id"`
	Status NumericRequestStatus `json:"status"`

	// EnvID The ID of the environment associated with the request.
	EnvID string `json:"env"`

	// Scopes A list of the information (scopes) that the request is asking for.
	Scopes []Scope `json:"scopes"`

	// Template The name of a template that customizes how the request is presented to the user.
	Template string `json:"template,omitempty"`

	// Link An authorization link. Passing this link to the user will prompt them to complete the request.
	Link string `json:"link"`

	// Phone The phone number to which the request link was sent, in E.184 format.
	Phone string `json:"phone,omitempty"`

	// Label An internal label for this request. You can use this field to help you track the
	// request in your own systems. Nametag stores this field, but does not process it at
	Label string `json:"label,omitempty"`

	// ExpiresAt The last time this request will be valid. After this time, the request is expired
	// and the user will no longer be able to complete it.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// CreateTemplateRequest defines model for CreateTemplateRequest.
type CreateTemplateRequest struct {
	// Name A descriptive name of the template
	Name string `json:"name"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline *string `json:"headline,omitempty"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline *string `json:"qr_headline,omitempty"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human readable form, e.g. "3 hours"
	ExpirationText *string `json:"expiration_text,omitempty"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText *string `json:"accept_text,omitempty"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText *string `json:"accepted_text,omitempty"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS *string `json:"install_message_sms,omitempty"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault *bool `json:"is_default,omitempty"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions,omitempty"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn *int `json:"scopes_expire_in,omitempty"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification *bool `json:"require_selfie_reverification,omitempty"`

	// QRCustomText The Custom QR code text for this template.
	QRCustomText *string `json:"qr_custom_text,omitempty"`
}

// CreateTemplateResponse defines model for CreateTemplateResponse.
type CreateTemplateResponse struct {
	// ID The unique identifier of the template
	ID string `json:"id"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	// Account * For Duo, the integration key
	// * For Okta, this field should be blank
	// * For Onelogin, the client ID, e.g. `98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4`
	Account string `json:"account,omitempty"`

	// Partition * For Duo, the API hostname, e.g. `api-33091yc9.duosecurity.com`.
	// * For Okta, the service hostname, e.g. `your-company.okta.com`.
	// * For Onelogin, the subdomain, e.g. `example.onelogin.com`.
	Partition string `json:"partition"`

	// Secret * For Duo, the secret key, e.g. `cv9wJSC10XDFRGY5L9DcgHuNtR76vM8kuB1sDCpc`
	// * For Okta, the API token, e.g. `21lgux-M8uJC4w-9kN_PL0ivV5tM81AvSd7l0IuAS3`
	// * For Onelogin, the client secret, e.g. `f3d4bd80d4d4007be3455453819d3359f8a5eb2eb66fdbc7bae5e44083605118`
	Secret string `json:"secret"`
}

// Directory defines model for Directory.
type Directory struct {
	// ID The unique identifier for the directory.
	ID string `json:"id"`

	// Env The environment this directory belongs to.
	Env string `json:"env"`

	// Kind The type of the directory connection.
	Kind DirectoryKind `json:"kind"`

	// Name The internal name of the directory.
	// This field is derived from inspecting the directory itself, for example for  Entra ID this field is the primary domain name. This field is used to you identify the directory.
	Name                      string              `json:"name"`
	AuthenticatePolicy        RecoveryPolicyRules `json:"authenticate_policy"`
	MfaPolicy                 RecoveryPolicyRules `json:"mfa_policy"`
	PasswordPolicy            RecoveryPolicyRules `json:"password_policy"`
	TemporaryAccessPassPolicy RecoveryPolicyRules `json:"temporary_access_pass_policy"`
	UnlockPolicy              RecoveryPolicyRules `json:"unlock_policy"`

	// TemporaryAccessPassLifetimeMinutes The validity period of a temporary access pass in minutes.
	// For Entra ID, this value must be between 10 and 43200 (equivalent to 30 days).  If not specified, the defaultLifetimeInMinutes setting in the  [Temporary Access Pass authentication method policy](https://learn.microsoft.com/en-us/graph/api/resources/temporaryaccesspassauthenticationmethodconfiguration?view=graph-rest-1.0) is applied.
	TemporaryAccessPassLifetimeMinutes *int `json:"temporary_access_pass_lifetime_minutes,omitempty"`

	// TemporaryAccessPassReusable True if temporary access passes can be used more than once. If unspecified,  temporary access passes are usable only once.
	TemporaryAccessPassReusable *bool               `json:"temporary_access_pass_reusable,omitempty"`
	Credentials                 *PartialCredentials `json:"credentials,omitempty"`

	// LastSyncStartedAt When the last sync started.
	LastSyncStartedAt *time.Time `json:"last_sync_started_at,omitempty"`

	// LastSyncCompletedAt When the last sync completed
	LastSyncCompletedAt *time.Time `json:"last_sync_completed_at,omitempty"`

	// LastSyncError An error describing the failure of the last sync, or null if the last sync was successful.
	LastSyncError *string `json:"last_sync_error,omitempty"`

	// Count The number of accounts in the directory.
	Count *int `json:"count,omitempty"`

	// NeedsReconnect If the directory needs to reconnect.
	NeedsReconnect *bool `json:"needs_reconnect,omitempty"`

	// SyncRunning true if the directory sync is currently running
	SyncRunning bool `json:"sync_running"`

	// BirthDateHMACSecretExists true if a shared secret for birth date HMACs has been set
	BirthDateHMACSecretExists bool `json:"birth_date_hmac_secret_exists"`
}

// DirectoryGroup defines model for DirectoryGroup.
type DirectoryGroup struct {
	// DirectoryImmutableIdentifier The unique identifier for the group.
	DirectoryImmutableIdentifier string `json:"directory_immutable_identifier"`

	// Name The display name of the group.
	Name string `json:"name"`
}

// DirectoryKind The type of the directory connection.
type DirectoryKind string

// Env defines model for Env.
type Env struct {
	// ID The identifier for this environment
	ID string `json:"id"`

	// Name The internal name for this environment
	Name string `json:"name"`

	// PublicName The name of the environment that is shared with people
	PublicName string `json:"public_name"`

	// LogoURL A URL to your logo, which is displayed in the Nametag mobile app.
	LogoURL string `json:"logo_url"`

	// TermsOfServiceURL The URL of the terms of service.
	//
	// Formerly, this URL was provided to end-users in the Nametag mobile app, but it
	// is no longer used.
	// Deprecated:
	TermsOfServiceURL string `json:"terms_of_service_url"`

	// CallbackURLs A list of valid URLs for use as OAuth 2.0 callback URLs.
	CallbackURLs []string `json:"callback_urls"`

	// Webhooks A list of webhooks.
	Webhooks []WebhookDefinition `json:"webhooks"`

	// Templates A list of request templates.
	Templates []Template  `json:"templates"`
	Storage   *EnvStorage `json:"storage,omitempty"`
}

// EnvStorage defines model for EnvStorage.
type EnvStorage struct {
	// S3BucketUS The S3 bucket for data stored in the United States. Must be in the us-east-2 AWS region.
	S3BucketUS *string `json:"s3_bucket_us,omitempty"`

	// S3BucketEU The S3 bucket for data stored in Europe. Must be in the eu-west-1 AWS region.
	S3BucketEU *string `json:"s3_bucket_eu,omitempty"`

	// S3BucketIN The S3 bucket for data stored in India. Must be in the ap-south-1 AWS region.
	S3BucketIN *string `json:"s3_bucket_in,omitempty"`

	// AWSRoleARN The role Nametag should use to access the S3 buckets.
	AWSRoleARN *string `json:"aws_role_arn,omitempty"`

	// AzureBlobSasUS Azure Blob Storage presigned (SAS) URL. Should be in the eastus region.
	AzureBlobSasUS *string `json:"azure_blob_us,omitempty"`

	// AzureBlobSasEU Azure Blob Storage presigned (SAS) URL. Should be in the northeurope region.
	AzureBlobSasEU *string `json:"azure_blob_eu,omitempty"`

	// AzureBlobSasIN Azure Blob Storage presigned (SAS) URL. Should be in the centralindia region.
	AzureBlobSasIN *string `json:"azure_blob_in,omitempty"`
}

// EnvUpdateRequest defines model for EnvUpdateRequest.
type EnvUpdateRequest struct {
	// Name Update the name of the environment, for internal use.
	Name *string `json:"name,omitempty"`

	// PublicName Update the public-facing name for your environment, typically your company or brand name.
	PublicName *string `json:"public_name,omitempty"`

	// CallbackURLs Set the list of allowed OAuth 2.0 callback URLs
	CallbackURLs []string `json:"callback_urls,omitempty"`

	// TermsOfServiceURL Update the terms of service URL.
	// Deprecated:
	TermsOfServiceURL *string `json:"terms_of_service_url,omitempty"`

	// RemoveWebhooks Remove webhooks from the environment (IDs of the webhooks to remove)
	RemoveWebhooks []string `json:"remove_webhooks,omitempty"`

	// AddWebhooks Add webhooks to the environment
	AddWebhooks   []WebhookDefinition      `json:"add_webhooks,omitempty"`
	UpdateWebhook *WebhookDefinitionUpdate `json:"update_webhook,omitempty"`
	Storage       *EnvStorage              `json:"storage,omitempty"`
}

// Expectation defines model for Expectation.
type Expectation struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the developer console.
	Scope Scope `json:"scope"`

	// Value The value you expect the person to have for this scope.
	Value string `json:"value"`
}

// GetDirectoriesResponse defines model for GetDirectoriesResponse.
type GetDirectoriesResponse struct {
	// Directories A list of all directories.
	Directories []Directory `json:"directories"`
}

// GetRequestsResponse defines model for GetRequestsResponse.
type GetRequestsResponse struct {
	Requests         []Request `json:"requests"`
	NextOffset       string    `json:"next_offset"`
	TotalResultCount int64     `json:"total_result_count"`
}

// GovtidDetailsValue defines model for GovtidDetailsValue.
type GovtidDetailsValue struct {
	Type GovtidType `json:"type"`

	// Issuer The issuer of the identity document, an  [ISO 3166-1 alpha 3 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) optionally followed by  a jurisdiction code, e.g. `USA.CA` or `CAN.ON`
	Issuer *string `json:"issuer,omitempty"`

	// Number The unique number of the identity document
	Number *string `json:"number,omitempty"`

	// Expiration The date when the identity document expires
	Expiration *openapi_types.Date `json:"expiration,omitempty"`
}

// GovtidType defines model for GovtidType.
type GovtidType string

// GroupRecoveryPolicy defines model for GroupRecoveryPolicy.
type GroupRecoveryPolicy struct {
	Group  DirectoryGroup `json:"group"`
	Policy RecoveryPolicy `json:"policy"`
}

// InviteOrgMemberRequest defines model for InviteOrgMemberRequest.
type InviteOrgMemberRequest struct {
	// Email The email address of the person you want to invite.
	Email openapi_types.Email `json:"email"`

	// Envs The list of environments the member will have access to. If the list contains `*`, the member will have access to all environments.
	Envs []string `json:"envs"`
	Role Role     `json:"role"`
}

// ListAPIKeysResponse defines model for ListAPIKeysResponse.
type ListAPIKeysResponse struct {
	// APIKeys A list of API keys
	APIKeys []APIKey `json:"apikeys"`
}

// ListEnvsResponse defines model for ListEnvsResponse.
type ListEnvsResponse struct {
	// Envs A list of all your environments.
	Envs []Env `json:"envs"`
}

// ListOrgMembersResponse defines model for ListOrgMembersResponse.
type ListOrgMembersResponse struct {
	// Members A list of each member of the organization
	Members []OrgMember `json:"members"`
}

// ListWebhooksResponse defines model for ListWebhooksResponse.
type ListWebhooksResponse struct {
	Webhooks []Webhook `json:"webhooks"`
}

// Location defines model for Location.
type Location struct {
	// Business Whether the location is a business.
	Business bool `json:"business,omitempty"`

	// City The city of the location.
	City string `json:"city,omitempty"`

	// Country The country of the location.
	Country string `json:"country,omitempty"`

	// Latitude The latitude of the location.
	Latitude float64 `json:"latitude"`

	// Longitude The longitude of the location.
	Longitude float64 `json:"longitude"`

	// PoBox Whether the location is a PO box.
	PoBox bool `json:"po_box,omitempty"`

	// Residential Whether the location is residential.
	Residential bool `json:"residential,omitempty"`

	// Subdivision The subdivision of the location (e.g. the state or province).
	Subdivision string `json:"subdivision,omitempty"`
}

// LogoKind defines model for LogoKind.
type LogoKind string

// NumericRequestStatus defines model for NumericRequestStatus.
type NumericRequestStatus int

// OAuth2AuthorizeResponse defines model for OAuth2AuthorizeResponse.
type OAuth2AuthorizeResponse struct {
	// RedirectURL The URL to redirect the user to authorize the directory.
	RedirectURL string `json:"redirect_url"`
}

// Org defines model for Org.
type Org struct {
	// Name The name of the organization, typically the name of your company
	Name string `json:"name"`
	Role Role   `json:"role"`

	// Envs A list of the environment IDs that you have access to.
	Envs []string `json:"envs"`
}

// OrgMember defines model for OrgMember.
type OrgMember struct {
	// MemberID A unique identifier of the member.
	MemberID string `json:"member_id"`
	Role     Role   `json:"role"`

	// Envs The list of environments the member has access to. If the list contains `*`, the member has access to all  environments.
	Envs []string `json:"envs"`

	// Name The name of the member.
	Name string `json:"name"`

	// Email The email address of the member.
	Email string `json:"email"`

	// ProfilePicture The URL of the profile picture of the member.
	ProfilePicture string `json:"profile_picture"`

	// InvitePending True if the member has been invited to the organization but has not  yet signed in.
	InvitePending bool `json:"invite_pending"`

	// RequestsCount The number of request the member has sent.
	RequestsCount *int `json:"requests_count,omitempty"`
}

// OrgUpdateRequest defines model for OrgUpdateRequest.
type OrgUpdateRequest struct {
	// Name The name of the organization, typically the name of your company
	Name               *string   `json:"name,omitempty"`
	AllowedIPAddresses *[]string `json:"allowed_ip_addresses,omitempty"`
}

// PartialCredentials defines model for PartialCredentials.
type PartialCredentials struct {
	// Account * For Duo, the integration key
	// * For Okta, this field should be blank
	// * For Onelogin, the client ID, e.g. `98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4`
	Account string `json:"account"`

	// Partition * For Duo, the API hostname, e.g. `api-33091yc9.duosecurity.com`.
	// * For Okta, the service hostname, e.g. `your-company.okta.com`.
	// * For Onelogin, the subdomain, e.g. `example.onelogin.com`.
	Partition string `json:"partition"`
}

// PollResponse defines model for PollResponse.
type PollResponse struct {
	Status           AuthorizeStatus `json:"status"`
	RedirectURI      string          `json:"redirect_uri,omitempty"`
	WaitingForReview bool            `json:"waiting_for_review,omitempty"`
}

// PropertiesResponse defines model for PropertiesResponse.
type PropertiesResponse struct {
	// Subject The subject of the request. This is the person whose properties are being requested.
	Subject string `json:"subject"`

	// Requests The requests that were made to get the properties.
	Requests []PropertyResponseRequest `json:"requests"`

	// Properties Properties of the person.
	Properties []PropertyResponse `json:"properties"`
}

// PropertyResponse defines model for PropertyResponse.
type PropertyResponse struct {
	// Expires When your access to this data expires
	Expires string `json:"expires,omitempty"`

	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the developer console.
	Scope Scope `json:"scope"`

	// Value The value of the property. The type of this field varies depending on the scope. See [this table](#scopes).
	Value interface{} `json:"value,omitempty"`

	// Status A value that tells you the disposition of the property. The value `200` means the data was shared.  The value `403` means the data has not been shared, the person has revoked your access, or `410` meaning  the request has expired.
	Status int `json:"status"`
}

// PropertyResponseRequest defines model for PropertyResponseRequest.
type PropertyResponseRequest struct {
	// ID A unique identifier for the request.
	ID string `json:"id"`

	// CreatedAt The time that the request was initiated
	CreatedAt time.Time `json:"created_at"`

	// Status The status of the request, 200 means accepted, 403 means rejected or canceled.
	Status int `json:"status"`

	// Scopes The scopes requested
	Scopes []Scope `json:"scopes"`
}

// RecoveryMicrositeFlow defines model for RecoveryMicrositeFlow.
type RecoveryMicrositeFlow string

// RecoveryMicrositeOperation defines model for RecoveryMicrositeOperation.
type RecoveryMicrositeOperation string

// RecoveryMicrositePresignRequest defines model for RecoveryMicrositePresignRequest.
type RecoveryMicrositePresignRequest struct {
	Email       *string                       `json:"email,omitempty"`
	Ttl         time.Duration                 `json:"ttl"`
	Operations  *[]RecoveryMicrositeOperation `json:"operations,omitempty"`
	Directories *[]string                     `json:"directories,omitempty"`
	Flow        *RecoveryMicrositeFlow        `json:"flow,omitempty"`
}

// RecoveryMicrositePresignResponse defines model for RecoveryMicrositePresignResponse.
type RecoveryMicrositePresignResponse struct {
	Url string `json:"url"`
}

// RecoveryPolicy defines model for RecoveryPolicy.
type RecoveryPolicy string

// RecoveryPolicyRules defines model for RecoveryPolicyRules.
type RecoveryPolicyRules struct {
	// Groups A list of policies to apply based on an Account's group membership.
	// When Nametag evaluates policy, the first entry in this list that matches will be applied. If no group matches, then the default policy is applied.
	Groups  []GroupRecoveryPolicy `json:"groups"`
	Default RecoveryPolicy        `json:"default"`
}

// RefreshWebhookSecretRequest defines model for RefreshWebhookSecretRequest.
type RefreshWebhookSecretRequest struct {
	// EnvID The environment identifier for which the webhook secret is to be refreshed
	EnvID string `json:"envID"`
}

// RefreshWebhookSecretResponse defines model for RefreshWebhookSecretResponse.
type RefreshWebhookSecretResponse struct {
	// WebhookSharedSecret The new webhook shared secret
	WebhookSharedSecret string `json:"webhook_shared_secret"`
}

// Request defines model for Request.
type Request struct {
	// ID A unique identifier for this request
	ID string `json:"id"`

	// CreatedAt Timestamp of when this request was created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt Timestamp of the last time this request was updated
	UpdatedAt time.Time `json:"updated_at"`

	// ExpiresAt Timestamp of when this request expires
	ExpiresAt time.Time `json:"expires_at"`

	// Ticket The request ticket (used to construct the link)
	Ticket string `json:"ticket"`

	// Link The URL which should be send to the user. This link launches the mobile app and prompts the user to verify their identity.
	Link string `json:"link"`

	// Phone The phone number that will receive an authorization link via SMS
	Phone *string `json:"phone,omitempty"`

	// Env The ID of the environment associated with the request
	Env      string `json:"env"`
	Template string `json:"template"`

	// Label The label for the request; can be empty
	Label    string          `json:"label"`
	Scopes   []Scope         `json:"scopes"`
	Status   RequestStatus   `json:"status"`
	Progress RequestProgress `json:"progress"`

	// Subject The subject of the request. Present only when `status` is `shared`. Use this as a parameter to [the properties endpoint](#get-properties) to fetch the data shared.
	Subject *string `json:"subject,omitempty"`

	// SubjectText A description of the subject (e.g. their name or email address) suitable for presentation in a user interface.
	SubjectText *string `json:"subject_text,omitempty"`

	// Requester The [member ID](#OrgMember) of the user that created this request. This field is absent for requests created via the API.
	Requester *string `json:"requester,omitempty"`

	// RequesterText A description of the requester suitable for presentation in a user interface (e.g. their name or email address)
	RequesterText *string              `json:"requester_text,omitempty"`
	Properties    RequestProperties    `json:"properties"`
	Mobile        *RequestMobileDevice `json:"mobile,omitempty"`
	Browser       *RequestBrowser      `json:"browser,omitempty"`

	// IsKnownUser If the user is known as an account
	IsKnownUser *bool `json:"is_known_user,omitempty"`

	// MarkedForDeletionAfter Indicates whether the person associated with this request has asked for their data to be deleted and the earliest time that will occur at.
	MarkedForDeletionAfter *time.Time `json:"marked_for_deletion_after,omitempty"`

	// Photo The photo associate with this person
	Photo *string `json:"photo,omitempty"`

	// ExternalIds External IDs for accounts if the user is known
	ExternalIds *[]string `json:"external_ids,omitempty"`
}

// RequestBrowser defines model for RequestBrowser.
type RequestBrowser struct {
	// UserAgent The browser's user agent
	UserAgent string `json:"user_agent"`

	// RemoteAddress The IP address of the browser  (This field is `null` unless the `nt:location:ip` scope is specified in the request)
	RemoteAddress         *string   `json:"remote_address,omitempty"`
	RemoteAddressLocation *Location `json:"remote_address_location,omitempty"`
}

// RequestMobileDevice defines model for RequestMobileDevice.
type RequestMobileDevice struct {
	// OS The full operating system name and version of the mobile device
	OS string `json:"os"`

	// Version The version of the Nametag app
	Version string `json:"version"`

	// IOS `true` if the device is an iOS device, otherwise `false`
	IOS bool `json:"ios"`

	// Android `true` if the device is an Android device, otherwise `false`
	Android bool `json:"android"`

	// FullApp `true` if the request was completed in the full Nametag app, otherwise `false`
	FullApp bool `json:"full_app"`

	// AppClip `true` if the request was completed in the iOS app clip, otherwise `false`
	AppClip bool `json:"app_clip"`

	// InstantApp `true` if the request was completed in the Android instant app, otherwise `false`
	InstantApp bool `json:"instant_app"`

	// RemoteAddress The IP address of the mobile device (This field is `null` unless the `nt:location:ip` scope is specified in the request)
	RemoteAddress         *string   `json:"remote_address,omitempty"`
	RemoteAddressLocation *Location `json:"remote_address_location,omitempty"`
}

// RequestProgress defines model for RequestProgress.
type RequestProgress string

// RequestProperties defines model for RequestProperties.
type RequestProperties struct {
	// Phone The person's phone number
	Phone *string `json:"phone,omitempty"`

	// LegalName The person's name from their identity document
	LegalName *string `json:"legal_name,omitempty"`

	// LegalFirstName The given name (first name) from their identity document
	LegalFirstName *string `json:"legal_first_name,omitempty"`

	// LegalLastName The family name (last name) from their identity document
	LegalLastName *string `json:"legal_last_name,omitempty"`

	// Name The person's preferred name
	Name *string `json:"name,omitempty"`

	// FirstName The person's preferred given (first) name
	FirstName *string `json:"first_name,omitempty"`

	// LastName The person's preferred family (last) name
	LastName *string `json:"last_name,omitempty"`

	// BirthDate The person's date of birth
	BirthDate *openapi_types.Date `json:"birth_date,omitempty"`

	// Email Verified email address
	Email *openapi_types.Email `json:"email,omitempty"`

	// UnverifiedEmail The email address provided by a user but not verified
	UnverifiedEmail *openapi_types.Email `json:"unverified_email,omitempty"`

	// AgeOver18 `true` if the person is over 18 years old, otherwise `false`
	AgeOver18 *bool `json:"age_over_18,omitempty"`

	// AgeOver21 `true` if the person is over 21 years old, otherwise `false`
	AgeOver21 *bool `json:"age_over_21,omitempty"`

	// ProfilePicture A URL to the person's preferred profile picture. Nametag checks that the image provided is the same person as pictured on their identity document.
	ProfilePicture *string `json:"profile_picture,omitempty"`

	// Address Verified postal address
	Address       *string             `json:"address,omitempty"`
	GovtidDetails *GovtidDetailsValue `json:"govtid_details,omitempty"`
}

// RequestStatus defines model for RequestStatus.
type RequestStatus string

// Role defines model for Role.
type Role string

// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the developer console.
type Scope string

// SubjectComparisonRequest defines model for SubjectComparisonRequest.
type SubjectComparisonRequest struct {
	// Expectations A list of expectations to compare against the person's properties.
	Expectations []Expectation `json:"expectations"`
}

// Template defines model for Template.
type Template struct {
	// ID A unique identifier for the template
	ID string `json:"id"`

	// CreatedAt When the template was created
	CreatedAt time.Time `json:"created_at"`

	// Name A descriptive name of the template
	Name string `json:"name"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline string `json:"headline"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline string `json:"qr_headline"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human readable form, e.g. "3 hours"
	ExpirationText string `json:"expiration_text"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText string `json:"accept_text"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText string `json:"accepted_text"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS string `json:"install_message_sms"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault bool `json:"is_default"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn int `json:"scopes_expire_in"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled bool `json:"enabled"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification bool `json:"require_selfie_reverification"`

	// QRCustomText The Custom QR code text for this template.
	QRCustomText string `json:"qr_custom_text"`
}

// TemplateScopeDefinition defines model for TemplateScopeDefinition.
type TemplateScopeDefinition struct {
	// Scope Scopes are used to describe the information you want people to share with you. In order to request a scope you  must first define it in your environment and provide additional parameters, such as what type of data and how  long you need the data. This is done separately for each environment you manage in the developer console.
	Scope Scope `json:"scope"`

	// RestrictEmailDomains If the scope definition is for nt:email or similar, require that the email domain match one of the provided values. If the scope definition is not for email, or if the list is empty, then emails from any domain are allowed.
	RestrictEmailDomains []string `json:"restrict_email_domains,omitempty"`
}

// TokenRequest defines model for TokenRequest.
type TokenRequest struct {
	GrantType    TokenRequestGrantType `json:"grant_type"`
	ClientID     string                `json:"client_id"`
	ClientSecret string                `json:"client_secret"`
	RedirectURI  string                `json:"redirect_uri"`
	Code         string                `json:"code"`
	CodeVerifier *string               `json:"code_verifier,omitempty"`
}

// TokenRequestGrantType defines model for TokenRequest.GrantType.
type TokenRequestGrantType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string                 `json:"access_token"`
	RefreshToken string                 `json:"refresh_token"`
	IDToken      string                 `json:"id_token"`
	Scope        string                 `json:"scope"`
	ExpiresIn    int                    `json:"expires_in"`
	TokenType    TokenResponseTokenType `json:"token_type"`
	Subject      string                 `json:"subject"`
}

// TokenResponseTokenType defines model for TokenResponse.TokenType.
type TokenResponseTokenType string

// TokenResponseError defines model for TokenResponseError.
type TokenResponseError struct {
	Code             string `json:"error"`
	ErrorDescription string `json:"error_description,omitempty"`
	URI              string `json:"uri,omitempty"`
}

// UpdateDirectoryRequest defines model for UpdateDirectoryRequest.
type UpdateDirectoryRequest struct {
	AuthenticatePolicy        *RecoveryPolicyRules `json:"authenticate_policy,omitempty"`
	PasswordPolicy            *RecoveryPolicyRules `json:"password_policy,omitempty"`
	MfaPolicy                 *RecoveryPolicyRules `json:"mfa_policy,omitempty"`
	UnlockPolicy              *RecoveryPolicyRules `json:"unlock_policy,omitempty"`
	TemporaryAccessPassPolicy *RecoveryPolicyRules `json:"temporary_access_pass_policy,omitempty"`

	// TemporaryAccessPassLifetimeMinutes The validity period of a temporary access pass in minutes
	TemporaryAccessPassLifetimeMinutes *int `json:"temporary_access_pass_lifetime_minutes,omitempty"`

	// TemporaryAccessPassReusable True if temporary access passes can be used more than once
	TemporaryAccessPassReusable *bool `json:"temporary_access_pass_reusable,omitempty"`

	// BirthDateHMACSecret A shared secret for hashed birth dates in the directory
	BirthDateHMACSecret []byte `json:"birth_date_hmac_secret,omitempty"`
}

// UpdateOrgMemberRequest defines model for UpdateOrgMemberRequest.
type UpdateOrgMemberRequest struct {
	// Envs The list of environments the member will have access to. If the list contains `*`, the member will have access
	// to all environments.
	Envs []string `json:"envs,omitempty"`
	Role *Role    `json:"role,omitempty"`
}

// UpdateRequestRequest defines model for UpdateRequestRequest.
type UpdateRequestRequest struct {
	// Label An internal label for this request. You can use this field to help you track the request in your own systems. Nametag stores this field, but does not process it.
	Label *string `json:"label,omitempty"`
}

// UpdateTemplateRequest defines model for UpdateTemplateRequest.
type UpdateTemplateRequest struct {
	// Name A descriptive name of the template
	Name *string `json:"name,omitempty"`

	// Headline The text that appears at the top of the mobile app when showing the request
	Headline *string `json:"headline,omitempty"`

	// QrHeadline The text that appears above the QR code when directing the user from desktop to mobile.
	QrHeadline *string `json:"qr_headline,omitempty"`

	// ExpirationText The text that describes when the request expires. This should include `{{.TTL}}` which is a placeholder  for the expiration of the data sharing authorization in human readable form, e.g. "3 hours"
	ExpirationText *string `json:"expiration_text,omitempty"`

	// AcceptText The text on the accept button in the mobile app.
	AcceptText *string `json:"accept_text,omitempty"`

	// AcceptedText The text that appears on the confirmation view after a request has been accepted.
	AcceptedText *string `json:"accepted_text,omitempty"`

	// InstallMessageSMS The contents of the SMS message sent to users to direct them to the mobile app. This must contain the  `{{.Link}}` which is a placeholder for the actual link.
	InstallMessageSMS *string `json:"install_message_sms,omitempty"`

	// IsDefault If true then this is the default template used when a template is not explicitly specified. There must be  exactly one default template.
	IsDefault *bool `json:"is_default,omitempty"`

	// ScopeDefinitions A list of scopes that are requested when requests are created with this template.
	ScopeDefinitions []TemplateScopeDefinition `json:"scope_definitions,omitempty"`

	// ScopesExpireIn How long the data sharing authorization should last, in seconds.
	ScopesExpireIn *int `json:"scopes_expire_in,omitempty"`

	// Enabled If true, then this template is enabled for requests. The default template must be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// RequireSelfieReverification If true, existing users must provide a new selfie to validate their identity.
	RequireSelfieReverification *bool `json:"require_selfie_reverification,omitempty"`

	// QRCustomText The Custom QR code text for this template.
	QRCustomText *string `json:"qr_custom_text,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	ID            string           `json:"id"`
	Status        int              `json:"status"`
	URL           string           `json:"url"`
	Body          string           `json:"body"`
	RequestHeader []WebhookHeader  `json:"request_header"`
	Attempts      []WebhookAttempt `json:"attempts"`
}

// WebhookAttempt defines model for WebhookAttempt.
type WebhookAttempt struct {
	StartTime time.Time       `json:"start_time"`
	EndTime   time.Time       `json:"end_time"`
	Status    int             `json:"status"`
	Header    []WebhookHeader `json:"header"`
	Body      string          `json:"body"`
	Error     string          `json:"error,omitempty"`
}

// WebhookDefinition defines model for WebhookDefinition.
type WebhookDefinition struct {
	// ID A unique identifier for the webhook definition.
	ID string `json:"id"`

	// URL The URL in your service that should be called, e.g. `https://example.com/__callback`
	URL string `json:"url"`

	// Enabled If true, then calls to this webhook should be made.
	Enabled bool `json:"enabled"`

	// Events The names of the events that should be sent.
	Events []WebhookEventType `json:"events"`

	// AuthorizationHeader The value of the Authorization header to include in the webhook request.
	AuthorizationHeader *string `json:"authorization_header,omitempty"`
}

// WebhookDefinitionUpdate defines model for WebhookDefinitionUpdate.
type WebhookDefinitionUpdate struct {
	ID      string             `json:"id"`
	URL     *string            `json:"url,omitempty"`
	Enabled *bool              `json:"enabled,omitempty"`
	Events  []WebhookEventType `json:"events,omitempty"`

	// AuthorizationHeader The value of the Authorization header to include in the webhook request.
	AuthorizationHeader *string `json:"authorization_header,omitempty"`
}

// WebhookEventType defines model for WebhookEventType.
type WebhookEventType string

// WebhookHeader defines model for WebhookHeader.
type WebhookHeader struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// N400 defines model for 400.
type N400 = BadRequestResponse

// BulkUploadAccountPhotosParams defines parameters for BulkUploadAccountPhotos.
type BulkUploadAccountPhotosParams struct {
	// Directory Modify only accounts in the specified directory(s)
	Directory string `form:"directory" json:"directory"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// Envs List only accounts in the specified environments
	Envs *[]string `form:"env,omitempty" json:"env,omitempty"`

	// Offset The offset to start from
	Offset *string `form:"offset,omitempty" json:"offset,omitempty"`

	// Count The number of items to return
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Verified Show only verified accounts
	Verified *bool `form:"verified,omitempty" json:"verified,omitempty"`

	// Directories Show only accounts in these directories
	Directories *[]string `form:"directory,omitempty" json:"directory,omitempty"`

	// Q Search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Sort Sort by this field, or prefix with "-" for descending order
	Sort *ListAccountsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListAccountsParamsSort defines parameters for ListAccounts.
type ListAccountsParamsSort string

// Oauth2CancelParams defines parameters for Oauth2Cancel.
type Oauth2CancelParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// Oauth2PollParams defines parameters for Oauth2Poll.
type Oauth2PollParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// DeleteLogoParams defines parameters for DeleteLogo.
type DeleteLogoParams struct {
	// Kind The kind of logo to remove
	Kind LogoKind `form:"kind" json:"kind"`
}

// UploadLogoMultipartBody defines parameters for UploadLogo.
type UploadLogoMultipartBody struct {
	Logo *openapi_types.File `json:"logo,omitempty"`
}

// UploadLogoParams defines parameters for UploadLogo.
type UploadLogoParams struct {
	// Kind The kind of logo to upload
	Kind *LogoKind `form:"kind,omitempty" json:"kind,omitempty"`
}

// ListEnvRequestsParams defines parameters for ListEnvRequests.
type ListEnvRequestsParams struct {
	Q            *string                            `form:"q,omitempty" json:"q,omitempty"`
	Requestor    *string                            `form:"requestor,omitempty" json:"requestor,omitempty"`
	Count        *int                               `form:"count,omitempty" json:"count,omitempty"`
	Offset       *string                            `form:"offset,omitempty" json:"offset,omitempty"`
	Sort         *ListEnvRequestsParamsSort         `form:"sort,omitempty" json:"sort,omitempty"`
	StatusFilter *ListEnvRequestsParamsStatusFilter `form:"statusFilter,omitempty" json:"statusFilter,omitempty"`
	UpdatedAt    *ListEnvRequestsParamsUpdatedAt    `form:"updatedAt,omitempty" json:"updatedAt,omitempty"`
}

// ListEnvRequestsParamsSort defines parameters for ListEnvRequests.
type ListEnvRequestsParamsSort string

// ListEnvRequestsParamsStatusFilter defines parameters for ListEnvRequests.
type ListEnvRequestsParamsStatusFilter string

// ListEnvRequestsParamsUpdatedAt defines parameters for ListEnvRequests.
type ListEnvRequestsParamsUpdatedAt string

// Oauth2AuthorizeParams defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeParamsResponseType defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsResponseType string

// Oauth2AuthorizeParamsResponseMode defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsResponseMode string

// Oauth2AuthorizeParamsCodeChallengeMethod defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsCodeChallengeMethod string

// Oauth2AuthorizeIframeParams defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeIframeParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeIframeParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeIframeParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeIframeParamsResponseType defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsResponseType string

// Oauth2AuthorizeIframeParamsResponseMode defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsResponseMode string

// Oauth2AuthorizeIframeParamsCodeChallengeMethod defines parameters for Oauth2AuthorizeIframe.
type Oauth2AuthorizeIframeParamsCodeChallengeMethod string

// Oauth2AuthorizeWithRequestParams defines parameters for Oauth2AuthorizeWithRequest.
type Oauth2AuthorizeWithRequestParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// DeletePersonPropertiesParams defines parameters for DeletePersonProperties.
type DeletePersonPropertiesParams struct {
	// Token The `id_token` you received from the `/token` endpoint. This may only be used if the subject is the special value `me`.
	Token  *string `form:"token,omitempty" json:"token,omitempty"`
	Origin *string `json:"Origin,omitempty"`
}

// GetPersonPropertiesParams defines parameters for GetPersonProperties.
type GetPersonPropertiesParams struct {
	// Token The `id_token` you received from the `/token` endpoint. This may only be used if the subject is the special value `me`.
	Token  *string `form:"token,omitempty" json:"token,omitempty"`
	Origin *string `json:"Origin,omitempty"`
}

// Oauth2AuthorizeWithExperienceParams defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParams struct {
	// ClientId The client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri The redirect URI
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// State The state
	State string `form:"state" json:"state"`

	// Scope Space-separated list of scopes
	Scope string `form:"scope" json:"scope"`

	// ResponseType The response type
	ResponseType Oauth2AuthorizeWithExperienceParamsResponseType `form:"response_type" json:"response_type"`

	// ResponseMode The response mode
	ResponseMode *Oauth2AuthorizeWithExperienceParamsResponseMode `form:"response_mode,omitempty" json:"response_mode,omitempty"`

	// CodeChallenge The code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod The code challenge method
	CodeChallengeMethod *Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// EmailHint The email hint
	EmailHint *openapi_types.Email `form:"email_hint,omitempty" json:"email_hint,omitempty"`

	// Template The template to use
	Template *string `form:"template,omitempty" json:"template,omitempty"`

	// Return The return URL
	Return *AuthorizeReturn `form:"return,omitempty" json:"return,omitempty"`
}

// Oauth2AuthorizeWithExperienceParamsResponseType defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsResponseType string

// Oauth2AuthorizeWithExperienceParamsResponseMode defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsResponseMode string

// Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod defines parameters for Oauth2AuthorizeWithExperience.
type Oauth2AuthorizeWithExperienceParamsCodeChallengeMethod string

// Oauth2AuthorizeWithRequestAndExperienceParams defines parameters for Oauth2AuthorizeWithRequestAndExperience.
type Oauth2AuthorizeWithRequestAndExperienceParams struct {
	// QuerySession The session token
	QuerySession *string `form:"session,omitempty" json:"session,omitempty"`

	// CookieSession The session token
	CookieSession *string `form:"session,omitempty" json:"session,omitempty"`
}

// BulkUpdateAccountsJSONRequestBody defines body for BulkUpdateAccounts for application/json ContentType.
type BulkUpdateAccountsJSONRequestBody = AccountBulkUpdateRequest

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody = AccountUpdateRequest

// CreateAPIKeyJSONRequestBody defines body for CreateAPIKey for application/json ContentType.
type CreateAPIKeyJSONRequestBody = CreateAPIKeyRequest

// UpdateAPIKeyJSONRequestBody defines body for UpdateAPIKey for application/json ContentType.
type UpdateAPIKeyJSONRequestBody = APIKeyUpdateRequest

// CreateDirectoryJSONRequestBody defines body for CreateDirectory for application/json ContentType.
type CreateDirectoryJSONRequestBody = CreateDirectoryRequest

// UpdateDirectoryJSONRequestBody defines body for UpdateDirectory for application/json ContentType.
type UpdateDirectoryJSONRequestBody = UpdateDirectoryRequest

// SetDirectoryCredentialsJSONRequestBody defines body for SetDirectoryCredentials for application/json ContentType.
type SetDirectoryCredentialsJSONRequestBody = Credentials

// CreateEnvJSONRequestBody defines body for CreateEnv for application/json ContentType.
type CreateEnvJSONRequestBody = CreateEnvRequest

// UpdateEnvJSONRequestBody defines body for UpdateEnv for application/json ContentType.
type UpdateEnvJSONRequestBody = EnvUpdateRequest

// UploadLogoMultipartRequestBody defines body for UploadLogo for multipart/form-data ContentType.
type UploadLogoMultipartRequestBody UploadLogoMultipartBody

// PresignRecoveryMicrositeURLJSONRequestBody defines body for PresignRecoveryMicrositeURL for application/json ContentType.
type PresignRecoveryMicrositeURLJSONRequestBody = RecoveryMicrositePresignRequest

// RefreshWebhookSecretJSONRequestBody defines body for RefreshWebhookSecret for application/json ContentType.
type RefreshWebhookSecretJSONRequestBody = RefreshWebhookSecretRequest

// CreateTemplateJSONRequestBody defines body for CreateTemplate for application/json ContentType.
type CreateTemplateJSONRequestBody = CreateTemplateRequest

// UpdateTemplateJSONRequestBody defines body for UpdateTemplate for application/json ContentType.
type UpdateTemplateJSONRequestBody = UpdateTemplateRequest

// UpdateOrgJSONRequestBody defines body for UpdateOrg for application/json ContentType.
type UpdateOrgJSONRequestBody = OrgUpdateRequest

// InviteOrgMemberJSONRequestBody defines body for InviteOrgMember for application/json ContentType.
type InviteOrgMemberJSONRequestBody = InviteOrgMemberRequest

// UpdateOrgMemberJSONRequestBody defines body for UpdateOrgMember for application/json ContentType.
type UpdateOrgMemberJSONRequestBody = UpdateOrgMemberRequest

// CreateRequestJSONRequestBody defines body for CreateRequest for application/json ContentType.
type CreateRequestJSONRequestBody = CreateRequestRequest

// UpdateRequestJSONRequestBody defines body for UpdateRequest for application/json ContentType.
type UpdateRequestJSONRequestBody = UpdateRequestRequest

// GetBulkPeoplePropertiesJSONRequestBody defines body for GetBulkPeopleProperties for application/json ContentType.
type GetBulkPeoplePropertiesJSONRequestBody = BulkRequest

// ComparePeopleJSONRequestBody defines body for ComparePeople for application/json ContentType.
type ComparePeopleJSONRequestBody = SubjectComparisonRequest

// Oauth2TokenFormdataRequestBody defines body for Oauth2Token for application/x-www-form-urlencoded ContentType.
type Oauth2TokenFormdataRequestBody = TokenRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BulkUploadAccountPhotosWithBody request with any body
	BulkUploadAccountPhotosWithBody(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateAccountsWithBody request with any body
	BulkUpdateAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateAccounts(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountWithBody request with any body
	UpdateAccountWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccount(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAccountPhotoWithBody request with any body
	UploadAccountPhotoWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAPIKeys request
	ListAPIKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAPIKeyWithBody request with any body
	CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAPIKey request
	DeleteAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIKey request
	GetAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAPIKeyWithBody request with any body
	UpdateAPIKeyWithBody(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAPIKey(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Cancel request
	Oauth2Cancel(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Poll request
	Oauth2Poll(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectories request
	ListDirectories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectoryWithBody request with any body
	CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectory request
	DeleteDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDirectory request
	GetDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDirectoryWithBody request with any body
	UpdateDirectoryWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDirectory(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDirectoryAuthorizationURL request
	GetDirectoryAuthorizationURL(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDirectoryCredentialsWithBody request with any body
	SetDirectoryCredentialsWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDirectoryCredentials(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncDirectory request
	SyncDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvs request
	ListEnvs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvWithBody request with any body
	CreateEnvWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnv(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnv request
	DeleteEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnv request
	GetEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvWithBody request with any body
	UpdateEnvWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnv(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogo request
	DeleteLogo(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLogoWithBody request with any body
	UploadLogoWithBody(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PresignRecoveryMicrositeURLWithBody request with any body
	PresignRecoveryMicrositeURLWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PresignRecoveryMicrositeURL(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshWebhookSecretWithBody request with any body
	RefreshWebhookSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshWebhookSecret(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnvRequests request
	ListEnvRequests(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvRequest request
	GetEnvRequest(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateWithBody request with any body
	CreateTemplateWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplate(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplate request
	DeleteTemplate(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTemplateWithBody request with any body
	UpdateTemplateWithBody(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTemplate(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhooks request
	ListWebhooks(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrg request
	GetOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrgWithBody request with any body
	UpdateOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrg(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrgMembers request
	ListOrgMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteOrgMemberWithBody request with any body
	InviteOrgMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteOrgMember(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOrgMember request
	RemoveOrgMember(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrgMemberWithBody request with any body
	UpdateOrgMemberWithBody(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrgMember(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequestWithBody request with any body
	CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelRequest request
	CancelRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequest request
	GetRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRequestWithBody request with any body
	UpdateRequestWithBody(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRequest(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Authorize request
	Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeIframe request
	Oauth2AuthorizeIframe(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithRequest request
	Oauth2AuthorizeWithRequest(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2Logout request
	Oauth2Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBulkPeoplePropertiesWithBody request with any body
	GetBulkPeoplePropertiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBulkPeopleProperties(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ComparePeopleWithBody request with any body
	ComparePeopleWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ComparePeople(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompareSelfieWithBody request with any body
	CompareSelfieWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersonProperties request
	DeletePersonProperties(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonProperties request
	GetPersonProperties(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2TokenWithBody request with any body
	Oauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Oauth2TokenWithFormdataBody(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithExperience request
	Oauth2AuthorizeWithExperience(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2AuthorizeWithRequestAndExperience request
	Oauth2AuthorizeWithRequestAndExperience(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BulkUploadAccountPhotosWithBody(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadAccountPhotosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAccounts(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, account)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithBody(c.Server, account, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccount(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequest(c.Server, account, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAccountPhotoWithBody(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAccountPhotoRequestWithBody(c.Server, account, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAPIKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIKeyRequest(c.Server, apiKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIKey(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIKeyRequest(c.Server, apiKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKeyWithBody(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequestWithBody(c.Server, apiKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKey(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequest(c.Server, apiKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Cancel(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2CancelRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Poll(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2PollRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectoryWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectoryRequestWithBody(c.Server, directory, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectory(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectoryRequest(c.Server, directory, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDirectoryAuthorizationURL(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDirectoryAuthorizationURLRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDirectoryCredentialsWithBody(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDirectoryCredentialsRequestWithBody(c.Server, directory, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDirectoryCredentials(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDirectoryCredentialsRequest(c.Server, directory, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncDirectory(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncDirectoryRequest(c.Server, directory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnv(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnv(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnv(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogo(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogoRequest(c.Server, env, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLogoWithBody(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLogoRequestWithBody(c.Server, env, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PresignRecoveryMicrositeURLWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPresignRecoveryMicrositeURLRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PresignRecoveryMicrositeURL(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPresignRecoveryMicrositeURLRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshWebhookSecretWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshWebhookSecretRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshWebhookSecret(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshWebhookSecretRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvRequests(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnvRequestsRequest(c.Server, env, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvRequest(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvRequestRequest(c.Server, env, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateWithBody(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequestWithBody(c.Server, env, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplate(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequest(c.Server, env, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplate(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplateRequest(c.Server, env, template)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplateWithBody(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequestWithBody(c.Server, env, template, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplate(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequest(c.Server, env, template, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhooks(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhooksRequest(c.Server, env)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrg(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrg(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrgMembers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrgMembersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteOrgMemberWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteOrgMemberRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteOrgMember(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteOrgMemberRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOrgMember(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOrgMemberRequest(c.Server, member)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgMemberWithBody(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgMemberRequestWithBody(c.Server, member, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgMember(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgMemberRequest(c.Server, member, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelRequestRequest(c.Server, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequest(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestRequest(c.Server, requestID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequestWithBody(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequestWithBody(c.Server, requestID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequest(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequest(c.Server, requestID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeIframe(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeIframeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithRequest(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithRequestRequest(c.Server, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2LogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkPeoplePropertiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkPeoplePropertiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkPeopleProperties(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkPeoplePropertiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComparePeopleWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComparePeopleRequestWithBody(c.Server, subject, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComparePeople(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComparePeopleRequest(c.Server, subject, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompareSelfieWithBody(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompareSelfieRequestWithBody(c.Server, subject, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersonProperties(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersonPropertiesRequest(c.Server, subject, scopes, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonProperties(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonPropertiesRequest(c.Server, subject, scopes, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenWithFormdataBody(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithExperience(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithExperienceRequest(c.Server, experience, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2AuthorizeWithRequestAndExperience(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeWithRequestAndExperienceRequest(c.Server, experience, requestID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBulkUploadAccountPhotosRequestWithBody generates requests for BulkUploadAccountPhotos with any type of body
func NewBulkUploadAccountPhotosRequestWithBody(server string, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/account/photos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directory", runtime.ParamLocationQuery, params.Directory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Envs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "env", runtime.ParamLocationQuery, *params.Envs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Verified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified", runtime.ParamLocationQuery, *params.Verified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Directories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directory", runtime.ParamLocationQuery, *params.Directories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateAccountsRequest calls the generic BulkUpdateAccounts builder with application/json body
func NewBulkUpdateAccountsRequest(server string, body BulkUpdateAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateAccountsRequestWithBody generates requests for BulkUpdateAccounts with any type of body
func NewBulkUpdateAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, account string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountRequest calls the generic UpdateAccount builder with application/json body
func NewUpdateAccountRequest(server string, account string, body UpdateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountRequestWithBody(server, account, "application/json", bodyReader)
}

// NewUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func NewUpdateAccountRequestWithBody(server string, account string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadAccountPhotoRequestWithBody generates requests for UploadAccountPhoto with any type of body
func NewUploadAccountPhotoRequestWithBody(server string, account string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/accounts/%s/photo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAPIKeysRequest generates requests for ListAPIKeys
func NewListAPIKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAPIKeyRequest calls the generic CreateAPIKey builder with application/json body
func NewCreateAPIKeyRequest(server string, body CreateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAPIKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAPIKeyRequestWithBody generates requests for CreateAPIKey with any type of body
func NewCreateAPIKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAPIKeyRequest generates requests for DeleteAPIKey
func NewDeleteAPIKeyRequest(server string, apiKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIKeyRequest generates requests for GetAPIKey
func NewGetAPIKeyRequest(server string, apiKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAPIKeyRequest calls the generic UpdateAPIKey builder with application/json body
func NewUpdateAPIKeyRequest(server string, apiKey string, body UpdateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAPIKeyRequestWithBody(server, apiKey, "application/json", bodyReader)
}

// NewUpdateAPIKeyRequestWithBody generates requests for UpdateAPIKey with any type of body
func NewUpdateAPIKeyRequestWithBody(server string, apiKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikey", runtime.ParamLocationPath, apiKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apikeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauth2CancelRequest generates requests for Oauth2Cancel
func NewOauth2CancelRequest(server string, requestID string, params *Oauth2CancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/authorize/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewOauth2PollRequest generates requests for Oauth2Poll
func NewOauth2PollRequest(server string, requestID string, params *Oauth2PollParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/authorize/%s/poll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewListDirectoriesRequest generates requests for ListDirectories
func NewListDirectoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectoryRequest calls the generic CreateDirectory builder with application/json body
func NewCreateDirectoryRequest(server string, body CreateDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectoryRequestWithBody generates requests for CreateDirectory with any type of body
func NewCreateDirectoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectoryRequest generates requests for DeleteDirectory
func NewDeleteDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDirectoryRequest generates requests for GetDirectory
func NewGetDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDirectoryRequest calls the generic UpdateDirectory builder with application/json body
func NewUpdateDirectoryRequest(server string, directory string, body UpdateDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDirectoryRequestWithBody(server, directory, "application/json", bodyReader)
}

// NewUpdateDirectoryRequestWithBody generates requests for UpdateDirectory with any type of body
func NewUpdateDirectoryRequestWithBody(server string, directory string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDirectoryAuthorizationURLRequest generates requests for GetDirectoryAuthorizationURL
func NewGetDirectoryAuthorizationURLRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDirectoryCredentialsRequest calls the generic SetDirectoryCredentials builder with application/json body
func NewSetDirectoryCredentialsRequest(server string, directory string, body SetDirectoryCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDirectoryCredentialsRequestWithBody(server, directory, "application/json", bodyReader)
}

// NewSetDirectoryCredentialsRequestWithBody generates requests for SetDirectoryCredentials with any type of body
func NewSetDirectoryCredentialsRequestWithBody(server string, directory string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncDirectoryRequest generates requests for SyncDirectory
func NewSyncDirectoryRequest(server string, directory string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "directory", runtime.ParamLocationPath, directory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/directories/%s/sync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnvsRequest generates requests for ListEnvs
func NewListEnvsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvRequest calls the generic CreateEnv builder with application/json body
func NewCreateEnvRequest(server string, body CreateEnvJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEnvRequestWithBody generates requests for CreateEnv with any type of body
func NewCreateEnvRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvRequest generates requests for DeleteEnv
func NewDeleteEnvRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvRequest generates requests for GetEnv
func NewGetEnvRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvRequest calls the generic UpdateEnv builder with application/json body
func NewUpdateEnvRequest(server string, env string, body UpdateEnvJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvRequestWithBody(server, env, "application/json", bodyReader)
}

// NewUpdateEnvRequestWithBody generates requests for UpdateEnv with any type of body
func NewUpdateEnvRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogoRequest generates requests for DeleteLogo
func NewDeleteLogoRequest(server string, env string, params *DeleteLogoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLogoRequestWithBody generates requests for UploadLogo with any type of body
func NewUploadLogoRequestWithBody(server string, env string, params *UploadLogoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPresignRecoveryMicrositeURLRequest calls the generic PresignRecoveryMicrositeURL builder with application/json body
func NewPresignRecoveryMicrositeURLRequest(server string, env string, body PresignRecoveryMicrositeURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPresignRecoveryMicrositeURLRequestWithBody(server, env, "application/json", bodyReader)
}

// NewPresignRecoveryMicrositeURLRequestWithBody generates requests for PresignRecoveryMicrositeURL with any type of body
func NewPresignRecoveryMicrositeURLRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/recovery_microsite/presign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshWebhookSecretRequest calls the generic RefreshWebhookSecret builder with application/json body
func NewRefreshWebhookSecretRequest(server string, env string, body RefreshWebhookSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshWebhookSecretRequestWithBody(server, env, "application/json", bodyReader)
}

// NewRefreshWebhookSecretRequestWithBody generates requests for RefreshWebhookSecret with any type of body
func NewRefreshWebhookSecretRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/refresh-webhook-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEnvRequestsRequest generates requests for ListEnvRequests
func NewListEnvRequestsRequest(server string, env string, params *ListEnvRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Requestor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestor", runtime.ParamLocationQuery, *params.Requestor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusFilter", runtime.ParamLocationQuery, *params.StatusFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAt", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvRequestRequest generates requests for GetEnvRequest
func NewGetEnvRequestRequest(server string, env string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTemplateRequest calls the generic CreateTemplate builder with application/json body
func NewCreateTemplateRequest(server string, env string, body CreateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateRequestWithBody(server, env, "application/json", bodyReader)
}

// NewCreateTemplateRequestWithBody generates requests for CreateTemplate with any type of body
func NewCreateTemplateRequestWithBody(server string, env string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTemplateRequest generates requests for DeleteTemplate
func NewDeleteTemplateRequest(server string, env string, template string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template", runtime.ParamLocationPath, template)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTemplateRequest calls the generic UpdateTemplate builder with application/json body
func NewUpdateTemplateRequest(server string, env string, template string, body UpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTemplateRequestWithBody(server, env, template, "application/json", bodyReader)
}

// NewUpdateTemplateRequestWithBody generates requests for UpdateTemplate with any type of body
func NewUpdateTemplateRequestWithBody(server string, env string, template string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template", runtime.ParamLocationPath, template)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebhooksRequest generates requests for ListWebhooks
func NewListWebhooksRequest(server string, env string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "env", runtime.ParamLocationPath, env)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/envs/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrgRequest generates requests for GetOrg
func NewGetOrgRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrgRequest calls the generic UpdateOrg builder with application/json body
func NewUpdateOrgRequest(server string, body UpdateOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrgRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateOrgRequestWithBody generates requests for UpdateOrg with any type of body
func NewUpdateOrgRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrgMembersRequest generates requests for ListOrgMembers
func NewListOrgMembersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteOrgMemberRequest calls the generic InviteOrgMember builder with application/json body
func NewInviteOrgMemberRequest(server string, body InviteOrgMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteOrgMemberRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteOrgMemberRequestWithBody generates requests for InviteOrgMember with any type of body
func NewInviteOrgMemberRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveOrgMemberRequest generates requests for RemoveOrgMember
func NewRemoveOrgMemberRequest(server string, member string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrgMemberRequest calls the generic UpdateOrgMember builder with application/json body
func NewUpdateOrgMemberRequest(server string, member string, body UpdateOrgMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrgMemberRequestWithBody(server, member, "application/json", bodyReader)
}

// NewUpdateOrgMemberRequestWithBody generates requests for UpdateOrgMember with any type of body
func NewUpdateOrgMemberRequestWithBody(server string, member string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/org/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRequestRequest calls the generic CreateRequest builder with application/json body
func NewCreateRequestRequest(server string, body CreateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestRequestWithBody generates requests for CreateRequest with any type of body
func NewCreateRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelRequestRequest generates requests for CancelRequest
func NewCancelRequestRequest(server string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestRequest generates requests for GetRequest
func NewGetRequestRequest(server string, requestID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequestRequest calls the generic UpdateRequest builder with application/json body
func NewUpdateRequestRequest(server string, requestID string, body UpdateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestRequestWithBody(server, requestID, "application/json", bodyReader)
}

// NewUpdateRequestRequestWithBody generates requests for UpdateRequest with any type of body
func NewUpdateRequestRequestWithBody(server string, requestID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauth2AuthorizeRequest generates requests for Oauth2Authorize
func NewOauth2AuthorizeRequest(server string, params *Oauth2AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeIframeRequest generates requests for Oauth2AuthorizeIframe
func NewOauth2AuthorizeIframeRequest(server string, params *Oauth2AuthorizeIframeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/iframe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeWithRequestRequest generates requests for Oauth2AuthorizeWithRequest
func NewOauth2AuthorizeWithRequestRequest(server string, requestID string, params *Oauth2AuthorizeWithRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewOauth2LogoutRequest generates requests for Oauth2Logout
func NewOauth2LogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBulkPeoplePropertiesRequest calls the generic GetBulkPeopleProperties builder with application/json body
func NewGetBulkPeoplePropertiesRequest(server string, body GetBulkPeoplePropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBulkPeoplePropertiesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetBulkPeoplePropertiesRequestWithBody generates requests for GetBulkPeopleProperties with any type of body
func NewGetBulkPeoplePropertiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewComparePeopleRequest calls the generic ComparePeople builder with application/json body
func NewComparePeopleRequest(server string, subject string, body ComparePeopleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewComparePeopleRequestWithBody(server, subject, "application/json", bodyReader)
}

// NewComparePeopleRequestWithBody generates requests for ComparePeople with any type of body
func NewComparePeopleRequestWithBody(server string, subject string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/compare", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompareSelfieRequestWithBody generates requests for CompareSelfie with any type of body
func NewCompareSelfieRequestWithBody(server string, subject string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/compare/selfie", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersonPropertiesRequest generates requests for DeletePersonProperties
func NewDeletePersonPropertiesRequest(server string, subject string, scopes string, params *DeletePersonPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopes", runtime.ParamLocationPath, scopes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Origin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Origin", headerParam0)
		}

	}

	return req, nil
}

// NewGetPersonPropertiesRequest generates requests for GetPersonProperties
func NewGetPersonPropertiesRequest(server string, subject string, scopes string, params *GetPersonPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subject", runtime.ParamLocationPath, subject)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopes", runtime.ParamLocationPath, scopes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/properties/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Origin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Origin", headerParam0)
		}

	}

	return req, nil
}

// NewOauth2TokenRequestWithFormdataBody calls the generic Oauth2Token builder with application/x-www-form-urlencoded body
func NewOauth2TokenRequestWithFormdataBody(server string, body Oauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewOauth2TokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewOauth2TokenRequestWithBody generates requests for Oauth2Token with any type of body
func NewOauth2TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauth2AuthorizeWithExperienceRequest generates requests for Oauth2AuthorizeWithExperience
func NewOauth2AuthorizeWithExperienceRequest(server string, experience string, params *Oauth2AuthorizeWithExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experience", runtime.ParamLocationPath, experience)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/x/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_mode", runtime.ParamLocationQuery, *params.ResponseMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_hint", runtime.ParamLocationQuery, *params.EmailHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Template != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "template", runtime.ParamLocationQuery, *params.Template); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Return != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return", runtime.ParamLocationQuery, *params.Return); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2AuthorizeWithRequestAndExperienceRequest generates requests for Oauth2AuthorizeWithRequestAndExperience
func NewOauth2AuthorizeWithRequestAndExperienceRequest(server string, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "experience", runtime.ParamLocationPath, experience)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request", runtime.ParamLocationPath, requestID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/x/%s/authorize/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.QuerySession != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session", runtime.ParamLocationQuery, *params.QuerySession); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.CookieSession != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "session", runtime.ParamLocationCookie, *params.CookieSession)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "session",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BulkUploadAccountPhotosWithBodyWithResponse request with any body
	BulkUploadAccountPhotosWithBodyWithResponse(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadAccountPhotosResp, error)

	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResp, error)

	// BulkUpdateAccountsWithBodyWithResponse request with any body
	BulkUpdateAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error)

	BulkUpdateAccountsWithResponse(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*GetAccountResp, error)

	// UpdateAccountWithBodyWithResponse request with any body
	UpdateAccountWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error)

	UpdateAccountWithResponse(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error)

	// UploadAccountPhotoWithBodyWithResponse request with any body
	UploadAccountPhotoWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAccountPhotoResp, error)

	// ListAPIKeysWithResponse request
	ListAPIKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIKeysResp, error)

	// CreateAPIKeyWithBodyWithResponse request with any body
	CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error)

	CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error)

	// DeleteAPIKeyWithResponse request
	DeleteAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResp, error)

	// GetAPIKeyWithResponse request
	GetAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*GetAPIKeyResp, error)

	// UpdateAPIKeyWithBodyWithResponse request with any body
	UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error)

	UpdateAPIKeyWithResponse(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error)

	// Oauth2CancelWithResponse request
	Oauth2CancelWithResponse(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*Oauth2CancelResp, error)

	// Oauth2PollWithResponse request
	Oauth2PollWithResponse(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*Oauth2PollResp, error)

	// ListDirectoriesWithResponse request
	ListDirectoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDirectoriesResp, error)

	// CreateDirectoryWithBodyWithResponse request with any body
	CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error)

	CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error)

	// DeleteDirectoryWithResponse request
	DeleteDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryResp, error)

	// GetDirectoryWithResponse request
	GetDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryResp, error)

	// UpdateDirectoryWithBodyWithResponse request with any body
	UpdateDirectoryWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error)

	UpdateDirectoryWithResponse(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error)

	// GetDirectoryAuthorizationURLWithResponse request
	GetDirectoryAuthorizationURLWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryAuthorizationURLResp, error)

	// SetDirectoryCredentialsWithBodyWithResponse request with any body
	SetDirectoryCredentialsWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error)

	SetDirectoryCredentialsWithResponse(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error)

	// SyncDirectoryWithResponse request
	SyncDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*SyncDirectoryResp, error)

	// ListEnvsWithResponse request
	ListEnvsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEnvsResp, error)

	// CreateEnvWithBodyWithResponse request with any body
	CreateEnvWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvResp, error)

	CreateEnvWithResponse(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvResp, error)

	// DeleteEnvWithResponse request
	DeleteEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*DeleteEnvResp, error)

	// GetEnvWithResponse request
	GetEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*GetEnvResp, error)

	// UpdateEnvWithBodyWithResponse request with any body
	UpdateEnvWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error)

	UpdateEnvWithResponse(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error)

	// DeleteLogoWithResponse request
	DeleteLogoWithResponse(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*DeleteLogoResp, error)

	// UploadLogoWithBodyWithResponse request with any body
	UploadLogoWithBodyWithResponse(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogoResp, error)

	// PresignRecoveryMicrositeURLWithBodyWithResponse request with any body
	PresignRecoveryMicrositeURLWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error)

	PresignRecoveryMicrositeURLWithResponse(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error)

	// RefreshWebhookSecretWithBodyWithResponse request with any body
	RefreshWebhookSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error)

	RefreshWebhookSecretWithResponse(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error)

	// ListEnvRequestsWithResponse request
	ListEnvRequestsWithResponse(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*ListEnvRequestsResp, error)

	// GetEnvRequestWithResponse request
	GetEnvRequestWithResponse(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*GetEnvRequestResp, error)

	// CreateTemplateWithBodyWithResponse request with any body
	CreateTemplateWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error)

	CreateTemplateWithResponse(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error)

	// DeleteTemplateWithResponse request
	DeleteTemplateWithResponse(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*DeleteTemplateResp, error)

	// UpdateTemplateWithBodyWithResponse request with any body
	UpdateTemplateWithBodyWithResponse(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	UpdateTemplateWithResponse(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	// ListWebhooksWithResponse request
	ListWebhooksWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListWebhooksResp, error)

	// GetOrgWithResponse request
	GetOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrgResp, error)

	// UpdateOrgWithBodyWithResponse request with any body
	UpdateOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error)

	UpdateOrgWithResponse(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error)

	// ListOrgMembersWithResponse request
	ListOrgMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrgMembersResp, error)

	// InviteOrgMemberWithBodyWithResponse request with any body
	InviteOrgMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error)

	InviteOrgMemberWithResponse(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error)

	// RemoveOrgMemberWithResponse request
	RemoveOrgMemberWithResponse(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*RemoveOrgMemberResp, error)

	// UpdateOrgMemberWithBodyWithResponse request with any body
	UpdateOrgMemberWithBodyWithResponse(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error)

	UpdateOrgMemberWithResponse(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error)

	// CreateRequestWithBodyWithResponse request with any body
	CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResp, error)

	CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResp, error)

	// CancelRequestWithResponse request
	CancelRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*CancelRequestResp, error)

	// GetRequestWithResponse request
	GetRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*GetRequestResp, error)

	// UpdateRequestWithBodyWithResponse request with any body
	UpdateRequestWithBodyWithResponse(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error)

	UpdateRequestWithResponse(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error)

	// Oauth2AuthorizeWithResponse request
	Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResp, error)

	// Oauth2AuthorizeIframeWithResponse request
	Oauth2AuthorizeIframeWithResponse(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeIframeResp, error)

	// Oauth2AuthorizeWithRequestWithResponse request
	Oauth2AuthorizeWithRequestWithResponse(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestResp, error)

	// Oauth2LogoutWithResponse request
	Oauth2LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Oauth2LogoutResp, error)

	// GetBulkPeoplePropertiesWithBodyWithResponse request with any body
	GetBulkPeoplePropertiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error)

	GetBulkPeoplePropertiesWithResponse(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error)

	// ComparePeopleWithBodyWithResponse request with any body
	ComparePeopleWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error)

	ComparePeopleWithResponse(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error)

	// CompareSelfieWithBodyWithResponse request with any body
	CompareSelfieWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompareSelfieResp, error)

	// DeletePersonPropertiesWithResponse request
	DeletePersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*DeletePersonPropertiesResp, error)

	// GetPersonPropertiesWithResponse request
	GetPersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersonPropertiesResp, error)

	// Oauth2TokenWithBodyWithResponse request with any body
	Oauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error)

	Oauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error)

	// Oauth2AuthorizeWithExperienceWithResponse request
	Oauth2AuthorizeWithExperienceWithResponse(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithExperienceResp, error)

	// Oauth2AuthorizeWithRequestAndExperienceWithResponse request
	Oauth2AuthorizeWithRequestAndExperienceWithResponse(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestAndExperienceResp, error)
}

type BulkUploadAccountPhotosResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkUploadAccountPhotosResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r BulkUploadAccountPhotosResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadAccountPhotosResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsList
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountBulkUpdateResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r BulkUpdateAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAccountPhotoResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadAccountPhotoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAccountPhotoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAPIKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPIKeysResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListAPIKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateAPIKeyResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKey
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAPIKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateAPIKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAPIKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2CancelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2CancelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2CancelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2PollResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PollResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2PollResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2PollResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectoriesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDirectoriesResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListDirectoriesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectoriesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateDirectoryResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Directory
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Directory
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDirectoryAuthorizationURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuth2AuthorizeResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetDirectoryAuthorizationURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDirectoryAuthorizationURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDirectoryCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r SetDirectoryCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDirectoryCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncDirectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r SyncDirectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncDirectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEnvsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListEnvsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateEnvResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Env
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateEnvResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLogoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UploadLogoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLogoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PresignRecoveryMicrositeURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryMicrositePresignResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r PresignRecoveryMicrositeURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PresignRecoveryMicrositeURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshWebhookSecretResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshWebhookSecretResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r RefreshWebhookSecretResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshWebhookSecretResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvRequestsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRequestsResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListEnvRequestsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvRequestsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetEnvRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTemplateResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeleteTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhooksResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhooksResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListWebhooksResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhooksResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Org
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetOrgResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrgResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateOrgResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrgResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrgMembersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListOrgMembersResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ListOrgMembersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrgMembersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r InviteOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r RemoveOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrgMemberResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateOrgMemberResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrgMemberResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateRequestResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CreateRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CancelRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r UpdateRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizeResponse
	JSON400      *AuthorizeResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeIframeResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeIframeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeIframeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithRequestResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithRequestResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithRequestResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2LogoutResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2LogoutResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2LogoutResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBulkPeoplePropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetBulkPeoplePropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBulkPeoplePropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ComparePeopleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComparisonResult
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r ComparePeopleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ComparePeopleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompareSelfieResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompareSelfieResult
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r CompareSelfieResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompareSelfieResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersonPropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r DeletePersonPropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersonPropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonPropertiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PropertiesResponse
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r GetPersonPropertiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonPropertiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2TokenResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *TokenResponseError
}

// Status returns HTTPResponse.Status
func (r Oauth2TokenResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2TokenResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithExperienceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizeResponse
	JSON400      *AuthorizeResponse
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithExperienceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithExperienceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2AuthorizeWithRequestAndExperienceResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeWithRequestAndExperienceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeWithRequestAndExperienceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BulkUploadAccountPhotosWithBodyWithResponse request with arbitrary body returning *BulkUploadAccountPhotosResp
func (c *ClientWithResponses) BulkUploadAccountPhotosWithBodyWithResponse(ctx context.Context, params *BulkUploadAccountPhotosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadAccountPhotosResp, error) {
	rsp, err := c.BulkUploadAccountPhotosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadAccountPhotosResp(rsp)
}

// ListAccountsWithResponse request returning *ListAccountsResp
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResp, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResp(rsp)
}

// BulkUpdateAccountsWithBodyWithResponse request with arbitrary body returning *BulkUpdateAccountsResp
func (c *ClientWithResponses) BulkUpdateAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error) {
	rsp, err := c.BulkUpdateAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAccountsResp(rsp)
}

func (c *ClientWithResponses) BulkUpdateAccountsWithResponse(ctx context.Context, body BulkUpdateAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAccountsResp, error) {
	rsp, err := c.BulkUpdateAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAccountsResp(rsp)
}

// GetAccountWithResponse request returning *GetAccountResp
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, account string, reqEditors ...RequestEditorFn) (*GetAccountResp, error) {
	rsp, err := c.GetAccount(ctx, account, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResp(rsp)
}

// UpdateAccountWithBodyWithResponse request with arbitrary body returning *UpdateAccountResp
func (c *ClientWithResponses) UpdateAccountWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error) {
	rsp, err := c.UpdateAccountWithBody(ctx, account, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResp(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithResponse(ctx context.Context, account string, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResp, error) {
	rsp, err := c.UpdateAccount(ctx, account, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResp(rsp)
}

// UploadAccountPhotoWithBodyWithResponse request with arbitrary body returning *UploadAccountPhotoResp
func (c *ClientWithResponses) UploadAccountPhotoWithBodyWithResponse(ctx context.Context, account string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAccountPhotoResp, error) {
	rsp, err := c.UploadAccountPhotoWithBody(ctx, account, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAccountPhotoResp(rsp)
}

// ListAPIKeysWithResponse request returning *ListAPIKeysResp
func (c *ClientWithResponses) ListAPIKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIKeysResp, error) {
	rsp, err := c.ListAPIKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIKeysResp(rsp)
}

// CreateAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateAPIKeyResp
func (c *ClientWithResponses) CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error) {
	rsp, err := c.CreateAPIKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResp(rsp)
}

func (c *ClientWithResponses) CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResp, error) {
	rsp, err := c.CreateAPIKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResp(rsp)
}

// DeleteAPIKeyWithResponse request returning *DeleteAPIKeyResp
func (c *ClientWithResponses) DeleteAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResp, error) {
	rsp, err := c.DeleteAPIKey(ctx, apiKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIKeyResp(rsp)
}

// GetAPIKeyWithResponse request returning *GetAPIKeyResp
func (c *ClientWithResponses) GetAPIKeyWithResponse(ctx context.Context, apiKey string, reqEditors ...RequestEditorFn) (*GetAPIKeyResp, error) {
	rsp, err := c.GetAPIKey(ctx, apiKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIKeyResp(rsp)
}

// UpdateAPIKeyWithBodyWithResponse request with arbitrary body returning *UpdateAPIKeyResp
func (c *ClientWithResponses) UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apiKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error) {
	rsp, err := c.UpdateAPIKeyWithBody(ctx, apiKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResp(rsp)
}

func (c *ClientWithResponses) UpdateAPIKeyWithResponse(ctx context.Context, apiKey string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResp, error) {
	rsp, err := c.UpdateAPIKey(ctx, apiKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResp(rsp)
}

// Oauth2CancelWithResponse request returning *Oauth2CancelResp
func (c *ClientWithResponses) Oauth2CancelWithResponse(ctx context.Context, requestID string, params *Oauth2CancelParams, reqEditors ...RequestEditorFn) (*Oauth2CancelResp, error) {
	rsp, err := c.Oauth2Cancel(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2CancelResp(rsp)
}

// Oauth2PollWithResponse request returning *Oauth2PollResp
func (c *ClientWithResponses) Oauth2PollWithResponse(ctx context.Context, requestID string, params *Oauth2PollParams, reqEditors ...RequestEditorFn) (*Oauth2PollResp, error) {
	rsp, err := c.Oauth2Poll(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2PollResp(rsp)
}

// ListDirectoriesWithResponse request returning *ListDirectoriesResp
func (c *ClientWithResponses) ListDirectoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDirectoriesResp, error) {
	rsp, err := c.ListDirectories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectoriesResp(rsp)
}

// CreateDirectoryWithBodyWithResponse request with arbitrary body returning *CreateDirectoryResp
func (c *ClientWithResponses) CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error) {
	rsp, err := c.CreateDirectoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResp(rsp)
}

func (c *ClientWithResponses) CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResp, error) {
	rsp, err := c.CreateDirectory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResp(rsp)
}

// DeleteDirectoryWithResponse request returning *DeleteDirectoryResp
func (c *ClientWithResponses) DeleteDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*DeleteDirectoryResp, error) {
	rsp, err := c.DeleteDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectoryResp(rsp)
}

// GetDirectoryWithResponse request returning *GetDirectoryResp
func (c *ClientWithResponses) GetDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryResp, error) {
	rsp, err := c.GetDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDirectoryResp(rsp)
}

// UpdateDirectoryWithBodyWithResponse request with arbitrary body returning *UpdateDirectoryResp
func (c *ClientWithResponses) UpdateDirectoryWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error) {
	rsp, err := c.UpdateDirectoryWithBody(ctx, directory, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectoryResp(rsp)
}

func (c *ClientWithResponses) UpdateDirectoryWithResponse(ctx context.Context, directory string, body UpdateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectoryResp, error) {
	rsp, err := c.UpdateDirectory(ctx, directory, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectoryResp(rsp)
}

// GetDirectoryAuthorizationURLWithResponse request returning *GetDirectoryAuthorizationURLResp
func (c *ClientWithResponses) GetDirectoryAuthorizationURLWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*GetDirectoryAuthorizationURLResp, error) {
	rsp, err := c.GetDirectoryAuthorizationURL(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDirectoryAuthorizationURLResp(rsp)
}

// SetDirectoryCredentialsWithBodyWithResponse request with arbitrary body returning *SetDirectoryCredentialsResp
func (c *ClientWithResponses) SetDirectoryCredentialsWithBodyWithResponse(ctx context.Context, directory string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error) {
	rsp, err := c.SetDirectoryCredentialsWithBody(ctx, directory, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDirectoryCredentialsResp(rsp)
}

func (c *ClientWithResponses) SetDirectoryCredentialsWithResponse(ctx context.Context, directory string, body SetDirectoryCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDirectoryCredentialsResp, error) {
	rsp, err := c.SetDirectoryCredentials(ctx, directory, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDirectoryCredentialsResp(rsp)
}

// SyncDirectoryWithResponse request returning *SyncDirectoryResp
func (c *ClientWithResponses) SyncDirectoryWithResponse(ctx context.Context, directory string, reqEditors ...RequestEditorFn) (*SyncDirectoryResp, error) {
	rsp, err := c.SyncDirectory(ctx, directory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncDirectoryResp(rsp)
}

// ListEnvsWithResponse request returning *ListEnvsResp
func (c *ClientWithResponses) ListEnvsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEnvsResp, error) {
	rsp, err := c.ListEnvs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvsResp(rsp)
}

// CreateEnvWithBodyWithResponse request with arbitrary body returning *CreateEnvResp
func (c *ClientWithResponses) CreateEnvWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvResp, error) {
	rsp, err := c.CreateEnvWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvResp(rsp)
}

func (c *ClientWithResponses) CreateEnvWithResponse(ctx context.Context, body CreateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvResp, error) {
	rsp, err := c.CreateEnv(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvResp(rsp)
}

// DeleteEnvWithResponse request returning *DeleteEnvResp
func (c *ClientWithResponses) DeleteEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*DeleteEnvResp, error) {
	rsp, err := c.DeleteEnv(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvResp(rsp)
}

// GetEnvWithResponse request returning *GetEnvResp
func (c *ClientWithResponses) GetEnvWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*GetEnvResp, error) {
	rsp, err := c.GetEnv(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvResp(rsp)
}

// UpdateEnvWithBodyWithResponse request with arbitrary body returning *UpdateEnvResp
func (c *ClientWithResponses) UpdateEnvWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error) {
	rsp, err := c.UpdateEnvWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvResp(rsp)
}

func (c *ClientWithResponses) UpdateEnvWithResponse(ctx context.Context, env string, body UpdateEnvJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvResp, error) {
	rsp, err := c.UpdateEnv(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvResp(rsp)
}

// DeleteLogoWithResponse request returning *DeleteLogoResp
func (c *ClientWithResponses) DeleteLogoWithResponse(ctx context.Context, env string, params *DeleteLogoParams, reqEditors ...RequestEditorFn) (*DeleteLogoResp, error) {
	rsp, err := c.DeleteLogo(ctx, env, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogoResp(rsp)
}

// UploadLogoWithBodyWithResponse request with arbitrary body returning *UploadLogoResp
func (c *ClientWithResponses) UploadLogoWithBodyWithResponse(ctx context.Context, env string, params *UploadLogoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLogoResp, error) {
	rsp, err := c.UploadLogoWithBody(ctx, env, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLogoResp(rsp)
}

// PresignRecoveryMicrositeURLWithBodyWithResponse request with arbitrary body returning *PresignRecoveryMicrositeURLResp
func (c *ClientWithResponses) PresignRecoveryMicrositeURLWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error) {
	rsp, err := c.PresignRecoveryMicrositeURLWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePresignRecoveryMicrositeURLResp(rsp)
}

func (c *ClientWithResponses) PresignRecoveryMicrositeURLWithResponse(ctx context.Context, env string, body PresignRecoveryMicrositeURLJSONRequestBody, reqEditors ...RequestEditorFn) (*PresignRecoveryMicrositeURLResp, error) {
	rsp, err := c.PresignRecoveryMicrositeURL(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePresignRecoveryMicrositeURLResp(rsp)
}

// RefreshWebhookSecretWithBodyWithResponse request with arbitrary body returning *RefreshWebhookSecretResp
func (c *ClientWithResponses) RefreshWebhookSecretWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error) {
	rsp, err := c.RefreshWebhookSecretWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshWebhookSecretResp(rsp)
}

func (c *ClientWithResponses) RefreshWebhookSecretWithResponse(ctx context.Context, env string, body RefreshWebhookSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshWebhookSecretResp, error) {
	rsp, err := c.RefreshWebhookSecret(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshWebhookSecretResp(rsp)
}

// ListEnvRequestsWithResponse request returning *ListEnvRequestsResp
func (c *ClientWithResponses) ListEnvRequestsWithResponse(ctx context.Context, env string, params *ListEnvRequestsParams, reqEditors ...RequestEditorFn) (*ListEnvRequestsResp, error) {
	rsp, err := c.ListEnvRequests(ctx, env, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnvRequestsResp(rsp)
}

// GetEnvRequestWithResponse request returning *GetEnvRequestResp
func (c *ClientWithResponses) GetEnvRequestWithResponse(ctx context.Context, env string, requestID string, reqEditors ...RequestEditorFn) (*GetEnvRequestResp, error) {
	rsp, err := c.GetEnvRequest(ctx, env, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvRequestResp(rsp)
}

// CreateTemplateWithBodyWithResponse request with arbitrary body returning *CreateTemplateResp
func (c *ClientWithResponses) CreateTemplateWithBodyWithResponse(ctx context.Context, env string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error) {
	rsp, err := c.CreateTemplateWithBody(ctx, env, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResp(rsp)
}

func (c *ClientWithResponses) CreateTemplateWithResponse(ctx context.Context, env string, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResp, error) {
	rsp, err := c.CreateTemplate(ctx, env, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResp(rsp)
}

// DeleteTemplateWithResponse request returning *DeleteTemplateResp
func (c *ClientWithResponses) DeleteTemplateWithResponse(ctx context.Context, env string, template string, reqEditors ...RequestEditorFn) (*DeleteTemplateResp, error) {
	rsp, err := c.DeleteTemplate(ctx, env, template, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplateResp(rsp)
}

// UpdateTemplateWithBodyWithResponse request with arbitrary body returning *UpdateTemplateResp
func (c *ClientWithResponses) UpdateTemplateWithBodyWithResponse(ctx context.Context, env string, template string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplateWithBody(ctx, env, template, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

func (c *ClientWithResponses) UpdateTemplateWithResponse(ctx context.Context, env string, template string, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplate(ctx, env, template, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

// ListWebhooksWithResponse request returning *ListWebhooksResp
func (c *ClientWithResponses) ListWebhooksWithResponse(ctx context.Context, env string, reqEditors ...RequestEditorFn) (*ListWebhooksResp, error) {
	rsp, err := c.ListWebhooks(ctx, env, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhooksResp(rsp)
}

// GetOrgWithResponse request returning *GetOrgResp
func (c *ClientWithResponses) GetOrgWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrgResp, error) {
	rsp, err := c.GetOrg(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgResp(rsp)
}

// UpdateOrgWithBodyWithResponse request with arbitrary body returning *UpdateOrgResp
func (c *ClientWithResponses) UpdateOrgWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error) {
	rsp, err := c.UpdateOrgWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgResp(rsp)
}

func (c *ClientWithResponses) UpdateOrgWithResponse(ctx context.Context, body UpdateOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgResp, error) {
	rsp, err := c.UpdateOrg(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgResp(rsp)
}

// ListOrgMembersWithResponse request returning *ListOrgMembersResp
func (c *ClientWithResponses) ListOrgMembersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOrgMembersResp, error) {
	rsp, err := c.ListOrgMembers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrgMembersResp(rsp)
}

// InviteOrgMemberWithBodyWithResponse request with arbitrary body returning *InviteOrgMemberResp
func (c *ClientWithResponses) InviteOrgMemberWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error) {
	rsp, err := c.InviteOrgMemberWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteOrgMemberResp(rsp)
}

func (c *ClientWithResponses) InviteOrgMemberWithResponse(ctx context.Context, body InviteOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteOrgMemberResp, error) {
	rsp, err := c.InviteOrgMember(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteOrgMemberResp(rsp)
}

// RemoveOrgMemberWithResponse request returning *RemoveOrgMemberResp
func (c *ClientWithResponses) RemoveOrgMemberWithResponse(ctx context.Context, member string, reqEditors ...RequestEditorFn) (*RemoveOrgMemberResp, error) {
	rsp, err := c.RemoveOrgMember(ctx, member, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOrgMemberResp(rsp)
}

// UpdateOrgMemberWithBodyWithResponse request with arbitrary body returning *UpdateOrgMemberResp
func (c *ClientWithResponses) UpdateOrgMemberWithBodyWithResponse(ctx context.Context, member string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error) {
	rsp, err := c.UpdateOrgMemberWithBody(ctx, member, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgMemberResp(rsp)
}

func (c *ClientWithResponses) UpdateOrgMemberWithResponse(ctx context.Context, member string, body UpdateOrgMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgMemberResp, error) {
	rsp, err := c.UpdateOrgMember(ctx, member, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgMemberResp(rsp)
}

// CreateRequestWithBodyWithResponse request with arbitrary body returning *CreateRequestResp
func (c *ClientWithResponses) CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResp, error) {
	rsp, err := c.CreateRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResp(rsp)
}

func (c *ClientWithResponses) CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResp, error) {
	rsp, err := c.CreateRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResp(rsp)
}

// CancelRequestWithResponse request returning *CancelRequestResp
func (c *ClientWithResponses) CancelRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*CancelRequestResp, error) {
	rsp, err := c.CancelRequest(ctx, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelRequestResp(rsp)
}

// GetRequestWithResponse request returning *GetRequestResp
func (c *ClientWithResponses) GetRequestWithResponse(ctx context.Context, requestID string, reqEditors ...RequestEditorFn) (*GetRequestResp, error) {
	rsp, err := c.GetRequest(ctx, requestID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestResp(rsp)
}

// UpdateRequestWithBodyWithResponse request with arbitrary body returning *UpdateRequestResp
func (c *ClientWithResponses) UpdateRequestWithBodyWithResponse(ctx context.Context, requestID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error) {
	rsp, err := c.UpdateRequestWithBody(ctx, requestID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResp(rsp)
}

func (c *ClientWithResponses) UpdateRequestWithResponse(ctx context.Context, requestID string, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResp, error) {
	rsp, err := c.UpdateRequest(ctx, requestID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResp(rsp)
}

// Oauth2AuthorizeWithResponse request returning *Oauth2AuthorizeResp
func (c *ClientWithResponses) Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResp, error) {
	rsp, err := c.Oauth2Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeResp(rsp)
}

// Oauth2AuthorizeIframeWithResponse request returning *Oauth2AuthorizeIframeResp
func (c *ClientWithResponses) Oauth2AuthorizeIframeWithResponse(ctx context.Context, params *Oauth2AuthorizeIframeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeIframeResp, error) {
	rsp, err := c.Oauth2AuthorizeIframe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeIframeResp(rsp)
}

// Oauth2AuthorizeWithRequestWithResponse request returning *Oauth2AuthorizeWithRequestResp
func (c *ClientWithResponses) Oauth2AuthorizeWithRequestWithResponse(ctx context.Context, requestID string, params *Oauth2AuthorizeWithRequestParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestResp, error) {
	rsp, err := c.Oauth2AuthorizeWithRequest(ctx, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithRequestResp(rsp)
}

// Oauth2LogoutWithResponse request returning *Oauth2LogoutResp
func (c *ClientWithResponses) Oauth2LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Oauth2LogoutResp, error) {
	rsp, err := c.Oauth2Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2LogoutResp(rsp)
}

// GetBulkPeoplePropertiesWithBodyWithResponse request with arbitrary body returning *GetBulkPeoplePropertiesResp
func (c *ClientWithResponses) GetBulkPeoplePropertiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error) {
	rsp, err := c.GetBulkPeoplePropertiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkPeoplePropertiesResp(rsp)
}

func (c *ClientWithResponses) GetBulkPeoplePropertiesWithResponse(ctx context.Context, body GetBulkPeoplePropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkPeoplePropertiesResp, error) {
	rsp, err := c.GetBulkPeopleProperties(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkPeoplePropertiesResp(rsp)
}

// ComparePeopleWithBodyWithResponse request with arbitrary body returning *ComparePeopleResp
func (c *ClientWithResponses) ComparePeopleWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error) {
	rsp, err := c.ComparePeopleWithBody(ctx, subject, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComparePeopleResp(rsp)
}

func (c *ClientWithResponses) ComparePeopleWithResponse(ctx context.Context, subject string, body ComparePeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*ComparePeopleResp, error) {
	rsp, err := c.ComparePeople(ctx, subject, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComparePeopleResp(rsp)
}

// CompareSelfieWithBodyWithResponse request with arbitrary body returning *CompareSelfieResp
func (c *ClientWithResponses) CompareSelfieWithBodyWithResponse(ctx context.Context, subject string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompareSelfieResp, error) {
	rsp, err := c.CompareSelfieWithBody(ctx, subject, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompareSelfieResp(rsp)
}

// DeletePersonPropertiesWithResponse request returning *DeletePersonPropertiesResp
func (c *ClientWithResponses) DeletePersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *DeletePersonPropertiesParams, reqEditors ...RequestEditorFn) (*DeletePersonPropertiesResp, error) {
	rsp, err := c.DeletePersonProperties(ctx, subject, scopes, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersonPropertiesResp(rsp)
}

// GetPersonPropertiesWithResponse request returning *GetPersonPropertiesResp
func (c *ClientWithResponses) GetPersonPropertiesWithResponse(ctx context.Context, subject string, scopes string, params *GetPersonPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersonPropertiesResp, error) {
	rsp, err := c.GetPersonProperties(ctx, subject, scopes, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonPropertiesResp(rsp)
}

// Oauth2TokenWithBodyWithResponse request with arbitrary body returning *Oauth2TokenResp
func (c *ClientWithResponses) Oauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error) {
	rsp, err := c.Oauth2TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenResp(rsp)
}

func (c *ClientWithResponses) Oauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenResp, error) {
	rsp, err := c.Oauth2TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenResp(rsp)
}

// Oauth2AuthorizeWithExperienceWithResponse request returning *Oauth2AuthorizeWithExperienceResp
func (c *ClientWithResponses) Oauth2AuthorizeWithExperienceWithResponse(ctx context.Context, experience string, params *Oauth2AuthorizeWithExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithExperienceResp, error) {
	rsp, err := c.Oauth2AuthorizeWithExperience(ctx, experience, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithExperienceResp(rsp)
}

// Oauth2AuthorizeWithRequestAndExperienceWithResponse request returning *Oauth2AuthorizeWithRequestAndExperienceResp
func (c *ClientWithResponses) Oauth2AuthorizeWithRequestAndExperienceWithResponse(ctx context.Context, experience string, requestID string, params *Oauth2AuthorizeWithRequestAndExperienceParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeWithRequestAndExperienceResp, error) {
	rsp, err := c.Oauth2AuthorizeWithRequestAndExperience(ctx, experience, requestID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeWithRequestAndExperienceResp(rsp)
}

// ParseBulkUploadAccountPhotosResp parses an HTTP response from a BulkUploadAccountPhotosWithResponse call
func ParseBulkUploadAccountPhotosResp(rsp *http.Response) (*BulkUploadAccountPhotosResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadAccountPhotosResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkUploadAccountPhotosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAccountsResp parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResp(rsp *http.Response) (*ListAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateAccountsResp parses an HTTP response from a BulkUpdateAccountsWithResponse call
func ParseBulkUpdateAccountsResp(rsp *http.Response) (*BulkUpdateAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountBulkUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAccountResp parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResp(rsp *http.Response) (*GetAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAccountResp parses an HTTP response from a UpdateAccountWithResponse call
func ParseUpdateAccountResp(rsp *http.Response) (*UpdateAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadAccountPhotoResp parses an HTTP response from a UploadAccountPhotoWithResponse call
func ParseUploadAccountPhotoResp(rsp *http.Response) (*UploadAccountPhotoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAccountPhotoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAPIKeysResp parses an HTTP response from a ListAPIKeysWithResponse call
func ParseListAPIKeysResp(rsp *http.Response) (*ListAPIKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPIKeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAPIKeyResp parses an HTTP response from a CreateAPIKeyWithResponse call
func ParseCreateAPIKeyResp(rsp *http.Response) (*CreateAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAPIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAPIKeyResp parses an HTTP response from a DeleteAPIKeyWithResponse call
func ParseDeleteAPIKeyResp(rsp *http.Response) (*DeleteAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAPIKeyResp parses an HTTP response from a GetAPIKeyWithResponse call
func ParseGetAPIKeyResp(rsp *http.Response) (*GetAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAPIKeyResp parses an HTTP response from a UpdateAPIKeyWithResponse call
func ParseUpdateAPIKeyResp(rsp *http.Response) (*UpdateAPIKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAPIKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2CancelResp parses an HTTP response from a Oauth2CancelWithResponse call
func ParseOauth2CancelResp(rsp *http.Response) (*Oauth2CancelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2CancelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOauth2PollResp parses an HTTP response from a Oauth2PollWithResponse call
func ParseOauth2PollResp(rsp *http.Response) (*Oauth2PollResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2PollResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDirectoriesResp parses an HTTP response from a ListDirectoriesWithResponse call
func ParseListDirectoriesResp(rsp *http.Response) (*ListDirectoriesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectoriesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDirectoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDirectoryResp parses an HTTP response from a CreateDirectoryWithResponse call
func ParseCreateDirectoryResp(rsp *http.Response) (*CreateDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDirectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDirectoryResp parses an HTTP response from a DeleteDirectoryWithResponse call
func ParseDeleteDirectoryResp(rsp *http.Response) (*DeleteDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDirectoryResp parses an HTTP response from a GetDirectoryWithResponse call
func ParseGetDirectoryResp(rsp *http.Response) (*GetDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Directory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateDirectoryResp parses an HTTP response from a UpdateDirectoryWithResponse call
func ParseUpdateDirectoryResp(rsp *http.Response) (*UpdateDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Directory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDirectoryAuthorizationURLResp parses an HTTP response from a GetDirectoryAuthorizationURLWithResponse call
func ParseGetDirectoryAuthorizationURLResp(rsp *http.Response) (*GetDirectoryAuthorizationURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDirectoryAuthorizationURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuth2AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetDirectoryCredentialsResp parses an HTTP response from a SetDirectoryCredentialsWithResponse call
func ParseSetDirectoryCredentialsResp(rsp *http.Response) (*SetDirectoryCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDirectoryCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSyncDirectoryResp parses an HTTP response from a SyncDirectoryWithResponse call
func ParseSyncDirectoryResp(rsp *http.Response) (*SyncDirectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncDirectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEnvsResp parses an HTTP response from a ListEnvsWithResponse call
func ParseListEnvsResp(rsp *http.Response) (*ListEnvsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEnvsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateEnvResp parses an HTTP response from a CreateEnvWithResponse call
func ParseCreateEnvResp(rsp *http.Response) (*CreateEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateEnvResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteEnvResp parses an HTTP response from a DeleteEnvWithResponse call
func ParseDeleteEnvResp(rsp *http.Response) (*DeleteEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnvResp parses an HTTP response from a GetEnvWithResponse call
func ParseGetEnvResp(rsp *http.Response) (*GetEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Env
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateEnvResp parses an HTTP response from a UpdateEnvWithResponse call
func ParseUpdateEnvResp(rsp *http.Response) (*UpdateEnvResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteLogoResp parses an HTTP response from a DeleteLogoWithResponse call
func ParseDeleteLogoResp(rsp *http.Response) (*DeleteLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUploadLogoResp parses an HTTP response from a UploadLogoWithResponse call
func ParseUploadLogoResp(rsp *http.Response) (*UploadLogoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLogoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePresignRecoveryMicrositeURLResp parses an HTTP response from a PresignRecoveryMicrositeURLWithResponse call
func ParsePresignRecoveryMicrositeURLResp(rsp *http.Response) (*PresignRecoveryMicrositeURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PresignRecoveryMicrositeURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryMicrositePresignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRefreshWebhookSecretResp parses an HTTP response from a RefreshWebhookSecretWithResponse call
func ParseRefreshWebhookSecretResp(rsp *http.Response) (*RefreshWebhookSecretResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshWebhookSecretResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshWebhookSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEnvRequestsResp parses an HTTP response from a ListEnvRequestsWithResponse call
func ParseListEnvRequestsResp(rsp *http.Response) (*ListEnvRequestsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnvRequestsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnvRequestResp parses an HTTP response from a GetEnvRequestWithResponse call
func ParseGetEnvRequestResp(rsp *http.Response) (*GetEnvRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateTemplateResp parses an HTTP response from a CreateTemplateWithResponse call
func ParseCreateTemplateResp(rsp *http.Response) (*CreateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteTemplateResp parses an HTTP response from a DeleteTemplateWithResponse call
func ParseDeleteTemplateResp(rsp *http.Response) (*DeleteTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateTemplateResp parses an HTTP response from a UpdateTemplateWithResponse call
func ParseUpdateTemplateResp(rsp *http.Response) (*UpdateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListWebhooksResp parses an HTTP response from a ListWebhooksWithResponse call
func ParseListWebhooksResp(rsp *http.Response) (*ListWebhooksResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhooksResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhooksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOrgResp parses an HTTP response from a GetOrgWithResponse call
func ParseGetOrgResp(rsp *http.Response) (*GetOrgResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrgResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOrgResp parses an HTTP response from a UpdateOrgWithResponse call
func ParseUpdateOrgResp(rsp *http.Response) (*UpdateOrgResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrgResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListOrgMembersResp parses an HTTP response from a ListOrgMembersWithResponse call
func ParseListOrgMembersResp(rsp *http.Response) (*ListOrgMembersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrgMembersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListOrgMembersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInviteOrgMemberResp parses an HTTP response from a InviteOrgMemberWithResponse call
func ParseInviteOrgMemberResp(rsp *http.Response) (*InviteOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRemoveOrgMemberResp parses an HTTP response from a RemoveOrgMemberWithResponse call
func ParseRemoveOrgMemberResp(rsp *http.Response) (*RemoveOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOrgMemberResp parses an HTTP response from a UpdateOrgMemberWithResponse call
func ParseUpdateOrgMemberResp(rsp *http.Response) (*UpdateOrgMemberResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrgMemberResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateRequestResp parses an HTTP response from a CreateRequestWithResponse call
func ParseCreateRequestResp(rsp *http.Response) (*CreateRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCancelRequestResp parses an HTTP response from a CancelRequestWithResponse call
func ParseCancelRequestResp(rsp *http.Response) (*CancelRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestResp parses an HTTP response from a GetRequestWithResponse call
func ParseGetRequestResp(rsp *http.Response) (*GetRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateRequestResp parses an HTTP response from a UpdateRequestWithResponse call
func ParseUpdateRequestResp(rsp *http.Response) (*UpdateRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2AuthorizeResp parses an HTTP response from a Oauth2AuthorizeWithResponse call
func ParseOauth2AuthorizeResp(rsp *http.Response) (*Oauth2AuthorizeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/html) unsupported

	case rsp.StatusCode == 400:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseOauth2AuthorizeIframeResp parses an HTTP response from a Oauth2AuthorizeIframeWithResponse call
func ParseOauth2AuthorizeIframeResp(rsp *http.Response) (*Oauth2AuthorizeIframeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeIframeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOauth2AuthorizeWithRequestResp parses an HTTP response from a Oauth2AuthorizeWithRequestWithResponse call
func ParseOauth2AuthorizeWithRequestResp(rsp *http.Response) (*Oauth2AuthorizeWithRequestResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithRequestResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOauth2LogoutResp parses an HTTP response from a Oauth2LogoutWithResponse call
func ParseOauth2LogoutResp(rsp *http.Response) (*Oauth2LogoutResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2LogoutResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBulkPeoplePropertiesResp parses an HTTP response from a GetBulkPeoplePropertiesWithResponse call
func ParseGetBulkPeoplePropertiesResp(rsp *http.Response) (*GetBulkPeoplePropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBulkPeoplePropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseComparePeopleResp parses an HTTP response from a ComparePeopleWithResponse call
func ParseComparePeopleResp(rsp *http.Response) (*ComparePeopleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ComparePeopleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComparisonResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCompareSelfieResp parses an HTTP response from a CompareSelfieWithResponse call
func ParseCompareSelfieResp(rsp *http.Response) (*CompareSelfieResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompareSelfieResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompareSelfieResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeletePersonPropertiesResp parses an HTTP response from a DeletePersonPropertiesWithResponse call
func ParseDeletePersonPropertiesResp(rsp *http.Response) (*DeletePersonPropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersonPropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPersonPropertiesResp parses an HTTP response from a GetPersonPropertiesWithResponse call
func ParseGetPersonPropertiesResp(rsp *http.Response) (*GetPersonPropertiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonPropertiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PropertiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2TokenResp parses an HTTP response from a Oauth2TokenWithResponse call
func ParseOauth2TokenResp(rsp *http.Response) (*Oauth2TokenResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2TokenResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest TokenResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOauth2AuthorizeWithExperienceResp parses an HTTP response from a Oauth2AuthorizeWithExperienceWithResponse call
func ParseOauth2AuthorizeWithExperienceResp(rsp *http.Response) (*Oauth2AuthorizeWithExperienceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithExperienceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AuthorizeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/html) unsupported

	case rsp.StatusCode == 400:
		// Content-type (text/html) unsupported

	}

	return response, nil
}

// ParseOauth2AuthorizeWithRequestAndExperienceResp parses an HTTP response from a Oauth2AuthorizeWithRequestAndExperienceWithResponse call
func ParseOauth2AuthorizeWithRequestAndExperienceResp(rsp *http.Response) (*Oauth2AuthorizeWithRequestAndExperienceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeWithRequestAndExperienceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
